
Portable National Semiconductor SC/MP Assembler [16.09]

                            ;===============================================================================
                            ;     _    _   _ ____  _____          _   _       ____   ____    ____  __ ____
                            ;    / \  | \ | / ___||  ___|__  _ __| |_| |__   / ___| / ___|  / /  \/  |  _ \
                            ;   / _ \ |  \| \___ \| |_ / _ \| '__| __| '_ \  \___ \| |     / /| |\/| | |_) |
                            ;  / ___ \| |\  |___) |  _| (_) | |  | |_| | | |  ___) | |___ / / | |  | |  __/
                            ; /_/   \_\_| \_|____/|_|  \___/|_|   \__|_| |_| |____/ \____/_/  |_|  |_|_|
                            ;
                            ; An Indirect Threaded ANS Forth for the SC/MP
                            ;-------------------------------------------------------------------------------
                            ; Copyright (C)2016 HandCoded Software Ltd.
                            ; All rights reserved.
                            ;
                            ; This work is made available under the terms of the Creative Commons
                            ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
                            ; following URL to see the details.
                            ;
                            ; http://creativecommons.org/licenses/by-nc-sa/4.0/
                            ;
                            ;===============================================================================
                            ; Notes:
                            ;
                            ; Of the three general purpose registers is used to hold the base address of the
                            ; system memory area which holds the Forth instructon pointer as well as the
                            ; current data and return stack pointers.
                            ;
                            ; Only the low byte of the data and return stack pointers is ever adjusted by a
                            ; stack operation limiting thier size to 256 bytes and they can not cross a 256
                            ; byte page boundary.
                            ;
                            ; R2(P3) contains the address of NEXT to allow native words to continue quickly
                            ;
                            ; Some of the high-level definitions are based on Bradford J. Rodriguez's
                            ; CamelForth implementations.
                            ;
                            ; Thoughts:
                            ;
                            ; Aligning word addresses on even bytes would speed up the IP += 2 in the inner
                            ; interpreter.
                            ;
                            ;-------------------------------------------------------------------------------
                            
                                            .INCLUDE "../em-scmp.inc"
                                            .list
                            
                            TXD             .macro
                                            .byte   X'20
                                            .endm
                            
                            RXD             .macro
                                            .byte   X'21
                                            .endm
                            ; Register assigments
                            
        00000000          = PC              .EQU    0               ; SC/MP program counter (pre-incremented)

Portable National Semiconductor SC/MP Assembler [16.09]

        00000001          = MA              .EQU    1               ; System memory base address
        00000002          = R1              .EQU    2               ; General purpose
        00000003          = R2              .EQU    3               ; Next address / General purpose
                            
                            ;===============================================================================
                            ;-------------------------------------------------------------------------------
                            
        00000000          = LAST            .SET    0
                            
        00000000          = NORMAL          .EQU    X'00
        00000080          = IMMEDIATE       .EQU    X'80
                            
                            WORD            .MACRO  NAME,TYPE
                            THIS            .SET    $
                                            .WORD   LAST
                                            .BYTE   TYPE
                                            .BYTE   STRLEN(NAME)
                                            .BYTE   NAME
                            LAST            .SET    THIS
                                            .ENDM
                            
                            NATIVE          .MACRO
                                            .WORD   $+1
                                            .ENDM
                            
                            FORTH           .MACRO
                                            .WORD   DO_COLON-1
                                            .ENDM
                            
                            ;===============================================================================
                            ;-------------------------------------------------------------------------------
                            
                                            .BSS
                                            .ORG    X'1000
                            
        00000080          = TIB_SIZE        .EQU    128
                            
001000  0000000000000000> : DSTACK          .SPACE  128
                            DSTACK_END      .SPACE  0
001080  0000000000000000> : TIB_AREA        .SPACE  TIB_SIZE
001100  0000000000000000> : RSTACK          .SPACE  128
                            RSTACK_END      .SPACE  0
001180  0000000000000000> : PAD_AREA        .SPACE  40
                            PAD_END         .SPACE  0
                            
0011A8  0000000000000000> : SYS_VARS        .SPACE  10
                            
        00000000          = IP              .EQU    0
        00000002          = WA              .EQU    2
        00000004          = RP              .EQU    4
        00000006          = SP              .EQU    6
        00000008          = UP              .EQU    8
                            
0011B2  0000000000000000> : USR_VARS        .SPACE  22

Portable National Semiconductor SC/MP Assembler [16.09]

                            
        00000000          = TO_IN_OFFSET    .EQU    0
        00000002          = BASE_OFFSET     .EQU    2
        00000004          = BLK_OFFSET      .EQU    4
        00000006          = DP_OFFSET       .EQU    6
        00000008          = LATEST_OFFSET   .EQU    8
        0000000A          = SCR_OFFSET      .EQU    10
        0000000C          = SOURCEID_OFFSET .EQU    12                      ; Input source flag
        0000000E          = STATE_OFFSET    .EQU    14                      ; Compiling/Interpreting flag
        00000010          = BUFFER_OFFSET   .EQU    16                      ; Address of the input buffer
        00000012          = LENGTH_OFFSET   .EQU    18                      ; Length of the input buffer
        00000014          = HP_OFFSET       .EQU    20
                            
                            NEXT_WORD       .SPACE  0
                            
                            ;===============================================================================
                            ; Power On Reset
                            ;-------------------------------------------------------------------------------
                            
                                            .CODE
                                            .ORG    X'C000
                            
00C000  08                :                 NOP
00C001  C4A8              :                 LDI     LO(SYS_VARS)    ; Initialise pointer to system variables
00C003  31                :                 XPAL    MA
00C004  C411              :                 LDI     HI(SYS_VARS)
00C006  35                :                 XPAH    MA
                            
00C007  C480              :                 LDI     LO(DSTACK_END)  ; Initialise the data stack
00C009  C906              :                 ST      SP+0(MA)
00C00B  C410              :                 LDI     HI(DSTACK_END)
00C00D  C907              :                 ST      SP+1(MA)
                            
00C00F  C480              :                 LDI     LO(RSTACK_END)  ; Initialise the return stack
00C011  C904              :                 ST      RP+0(MA)
00C013  C411              :                 LDI     HI(RSTACK_END)
00C015  C905              :                 ST      RP+1(MA)
                            
00C017  C4B2              :                 LDI     LO(USR_VARS)    ; Initialise the USER pointer
00C019  C908              :                 ST      UP+0(MA)
00C01B  C411              :                 LDI     HI(USR_VARS)
00C01D  C909              :                 ST      UP+1(MA)
                            
00C01F  C42E              :                 LDI     LO(COLD)        ; Initialise the IP
00C021  C900              :                 ST      IP+0(MA)
00C023  C4C0              :                 LDI     HI(COLD)
00C025  C901              :                 ST      IP+1(MA)
                            
00C027  C489              :                 LDI     LO(NEXT-1)      ; Initialise pointer to NEXT
00C029  33                :                 XPAL    R2
00C02A  C4D0              :                 LDI     HI(NEXT-1)
00C02C  37                :                 XPAH    R2
00C02D  3F                :                 XPPC    R2              ; And start COLD execution
                            

Portable National Semiconductor SC/MP Assembler [16.09]

00C02E  0EC1              : COLD:           .WORD   DECIMAL
00C030  DCC0              :                 .WORD   ZERO
00C032  88C0              :                 .WORD   BLK
00C034  32C1              :                 .WORD   STORE
00C036  F3C0              :                 .WORD   FALSE
00C038  C8C0              :                 .WORD   STATE
00C03A  32C1              :                 .WORD   STORE
00C03C  74D2C811          :                 .WORD   DO_LITERAL,NEXT_WORD
00C040  96C0              :                 .WORD   DP
00C042  32C1              :                 .WORD   STORE
00C044  74D2F9D6          :                 .WORD   DO_LITERAL,LAST_WORD
00C048  C9C1              :                 .WORD   FETCH
00C04A  A8C0              :                 .WORD   LATEST
00C04C  32C1              :                 .WORD   STORE
00C04E  34D4              :                 .WORD   CR
00C050  34D4              :                 .WORD   CR
00C052  CBD6              :                 .WORD   DO_TITLE
00C054  BCD4              :                 .WORD   TYPE
00C056  34D4              :                 .WORD   CR
00C058  34D4              :                 .WORD   CR
00C05A  15CB              :                 .WORD   ABORT
                            
                            ;===============================================================================
                            ; System/User Variables
                            ;-------------------------------------------------------------------------------
                            
                            ; #TIB ( -- a-addr )
                            ;
                            ; a-addr is the address of a cell containing the number of characters in the
                            ; terminal input buffer.
                            
                                            WORD    "#TIB",NORMAL
        0000C05C          = THIS            .SET    $
00C05C  0000              +                 .WORD   LAST
00C05E  00                +                 .BYTE   NORMAL
00C05F  04                +                 .BYTE   STRLEN("#TIB")
00C060  23544942          +                 .BYTE   "#TIB"
        0000C05C          = LAST            .SET    THIS
00C064  6DD3              : HASH_TIB:       .WORD   DO_USER-1
00C066  68C0              :                 .WORD   $+2
00C068  7E00              :                 .WORD   TIB_SIZE-2
                            
                            ; >IN ( -- a-addr )
                            ;
                            ; a-addr is the address of a cell containing the offset in characters from the
                            ; start of the input buffer to the start of the parse area.
                            
                                            WORD    ">IN",NORMAL
        0000C06A          = THIS            .SET    $
00C06A  5CC0              +                 .WORD   LAST
00C06C  00                +                 .BYTE   NORMAL
00C06D  03                +                 .BYTE   STRLEN(">IN")
00C06E  3E494E            +                 .BYTE   ">IN"
        0000C06A          = LAST            .SET    THIS

Portable National Semiconductor SC/MP Assembler [16.09]

00C071  6DD3              : TO_IN:          .WORD   DO_USER-1
00C073  0000              :                 .WORD   TO_IN_OFFSET
                            
                            ; BASE ( -- a-addr )
                            ;
                            ; a-addr is the address of a cell containing the current number-conversion
                            ; radix {{2...36}}.
                            
                                            WORD    "BASE",NORMAL
        0000C075          = THIS            .SET    $
00C075  6AC0              +                 .WORD   LAST
00C077  00                +                 .BYTE   NORMAL
00C078  04                +                 .BYTE   STRLEN("BASE")
00C079  42415345          +                 .BYTE   "BASE"
        0000C075          = LAST            .SET    THIS
00C07D  6DD3              : BASE:           .WORD   DO_USER-1
00C07F  0200              :                 .WORD   BASE_OFFSET
                            
                            ; BLK ( -- a-addr )
                            ;
                            ; a-addr is the address of a cell containing zero or the number of the mass-
                            ; storage block being interpreted. If BLK contains zero, the input source is
                            ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
                            ; ambiguous condition exists if a program directly alters the contents of BLK.
                            
                                            WORD    "BLK",NORMAL
        0000C081          = THIS            .SET    $
00C081  75C0              +                 .WORD   LAST
00C083  00                +                 .BYTE   NORMAL
00C084  03                +                 .BYTE   STRLEN("BLK")
00C085  424C4B            +                 .BYTE   "BLK"
        0000C081          = LAST            .SET    THIS
00C088  6DD3              : BLK:            .WORD   DO_USER-1
00C08A  0400              :                 .WORD   BLK_OFFSET
                            
                            ; (BUFFER)
                            
00C08C  6DD3              : BUFFER:         .WORD   DO_USER-1
00C08E  1000              :                 .WORD   BUFFER_OFFSET
                            
                            ; DP ( -- a-addr )
                            ;
                            ; Dictionary Pointer
                            
                                            WORD    "DP",NORMAL
        0000C090          = THIS            .SET    $
00C090  81C0              +                 .WORD   LAST
00C092  00                +                 .BYTE   NORMAL
00C093  02                +                 .BYTE   STRLEN("DP")
00C094  4450              +                 .BYTE   "DP"
        0000C090          = LAST            .SET    THIS
00C096  6DD3              : DP:             .WORD   DO_USER-1
00C098  0600              :                 .WORD   DP_OFFSET
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; HP ( -- a-addr )
                            ;
                            ; Hold Pointer
                            
00C09A  6DD3              : HP:             .WORD   DO_USER-1
00C09C  1400              :                 .WORD   HP_OFFSET
                            
                            ; LATEST ( -- a-addr )
                            
                                            WORD    "LATEST",NORMAL
        0000C09E          = THIS            .SET    $
00C09E  90C0              +                 .WORD   LAST
00C0A0  00                +                 .BYTE   NORMAL
00C0A1  06                +                 .BYTE   STRLEN("LATEST")
00C0A2  4C4154455354      +                 .BYTE   "LATEST"
        0000C09E          = LAST            .SET    THIS
00C0A8  6DD3              : LATEST:         .WORD   DO_USER-1
00C0AA  0800              :                 .WORD   LATEST_OFFSET
                            
                            ; (LENGTH)
                            
00C0AC  6DD3              : LENGTH:         .WORD   DO_USER-1
00C0AE  1200              :                 .WORD   LENGTH_OFFSET
                            
                            ; SCR ( -- a-addr )
                            ;
                            ; a-addr is the address of a cell containing the block number of the block most
                            ; recently LISTed.
                            
                                            WORD    "SCR",NORMAL
        0000C0B0          = THIS            .SET    $
00C0B0  9EC0              +                 .WORD   LAST
00C0B2  00                +                 .BYTE   NORMAL
00C0B3  03                +                 .BYTE   STRLEN("SCR")
00C0B4  534352            +                 .BYTE   "SCR"
        0000C0B0          = LAST            .SET    THIS
00C0B7  6DD3              : SCR:            .WORD   DO_USER-1
00C0B9  0A00              :                 .WORD   SCR_OFFSET
                            
                            ; (SOURCE-ID)
                            
00C0BB  6DD3              : SOURCEID:       .WORD   DO_USER-1
00C0BD  0C00              :                 .WORD   SOURCEID_OFFSET
                            
                            ; STATE ( -- a-addr )
                            ;
                            ; a-addr is the address of a cell containing the compilation-state flag. STATE
                            ; is true when in compilation state, false otherwise. The true value in STATE
                            ; is non-zero, but is otherwise implementation-defined.
                            
                                            WORD    "STATE",NORMAL
        0000C0BF          = THIS            .SET    $
00C0BF  B0C0              +                 .WORD   LAST
00C0C1  00                +                 .BYTE   NORMAL

Portable National Semiconductor SC/MP Assembler [16.09]

00C0C2  05                +                 .BYTE   STRLEN("STATE")
00C0C3  5354415445        +                 .BYTE   "STATE"
        0000C0BF          = LAST            .SET    THIS
00C0C8  6DD3              : STATE:          .WORD   DO_USER-1
00C0CA  0E00              :                 .WORD   STATE_OFFSET
                            
                            ; TIB ( -- c-addr )
                            ;
                            ; c-addr is the address of the terminal input buffer.
                            
                                            WORD    "TIB",NORMAL
        0000C0CC          = THIS            .SET    $
00C0CC  BFC0              +                 .WORD   LAST
00C0CE  00                +                 .BYTE   NORMAL
00C0CF  03                +                 .BYTE   STRLEN("TIB")
00C0D0  544942            +                 .BYTE   "TIB"
        0000C0CC          = LAST            .SET    THIS
00C0D3  B6D1              : TIB:            .WORD   DO_CONSTANT-1
00C0D5  8010              :                 .WORD   TIB_AREA
                            
                            ;===============================================================================
                            ; Constants
                            ;-------------------------------------------------------------------------------
                            
                            ; 0 ( -- 0 )
                            ;
                            ; Push the constant value zero on the stack
                            
                                            WORD    "0",NORMAL
        0000C0D7          = THIS            .SET    $
00C0D7  CCC0              +                 .WORD   LAST
00C0D9  00                +                 .BYTE   NORMAL
00C0DA  01                +                 .BYTE   STRLEN("0")
00C0DB  30                +                 .BYTE   "0"
        0000C0D7          = LAST            .SET    THIS
00C0DC  B6D1              : ZERO:           .WORD   DO_CONSTANT-1
00C0DE  0000              :                 .WORD   0
                            
                            ; BL ( -- char )
                            ;
                            ; char is the character value for a space.
                            
                                            WORD    "BL",NORMAL
        0000C0E0          = THIS            .SET    $
00C0E0  D7C0              +                 .WORD   LAST
00C0E2  00                +                 .BYTE   NORMAL
00C0E3  02                +                 .BYTE   STRLEN("BL")
00C0E4  424C              +                 .BYTE   "BL"
        0000C0E0          = LAST            .SET    THIS
00C0E6  B7D1              : BL:             .WORD   DO_CONSTANT
00C0E8  2000              :                 .WORD   ' '
                            
                            ; FALSE ( -- false )
                            ;

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; Return a false flag.
                            
                                            WORD    "FALSE",NORMAL
        0000C0EA          = THIS            .SET    $
00C0EA  E0C0              +                 .WORD   LAST
00C0EC  00                +                 .BYTE   NORMAL
00C0ED  05                +                 .BYTE   STRLEN("FALSE")
00C0EE  46414C5345        +                 .BYTE   "FALSE"
        0000C0EA          = LAST            .SET    THIS
00C0F3  B6D1              : FALSE:          .WORD   DO_CONSTANT-1
00C0F5  0000              :                 .WORD   0
                            
                            ; TRUE ( -- true )
                            ;
                            ; Return a true flag, a single-cell value with all bits set.
                            
                                            WORD    "TRUE",NORMAL
        0000C0F7          = THIS            .SET    $
00C0F7  EAC0              +                 .WORD   LAST
00C0F9  00                +                 .BYTE   NORMAL
00C0FA  04                +                 .BYTE   STRLEN("TRUE")
00C0FB  54525545          +                 .BYTE   "TRUE"
        0000C0F7          = LAST            .SET    THIS
00C0FF  B6D1              : TRUE:           .WORD   DO_CONSTANT-1
00C101  FFFF              :                 .WORD   -1
                            
                            ;===============================================================================
                            ; Radix
                            ;-------------------------------------------------------------------------------
                            
                            ; DECIMAL ( -- )
                            ;
                            ; Set the numeric conversion radix to ten (decimal).
                            
                                            WORD    "DECIMAL",NORMAL
        0000C103          = THIS            .SET    $
00C103  F7C0              +                 .WORD   LAST
00C105  00                +                 .BYTE   NORMAL
00C106  07                +                 .BYTE   STRLEN("DECIMAL")
00C107  444543494D414C    +                 .BYTE   "DECIMAL"
        0000C103          = LAST            .SET    THIS
                            DECIMAL:        FORTH
00C10E  6ED0              +                 .WORD   DO_COLON-1
00C110  74D20A00          :                 .WORD   DO_LITERAL,10
00C114  7DC0              :                 .WORD   BASE
00C116  32C1              :                 .WORD   STORE
00C118  86CB              :                 .WORD   EXIT
                            
                            ; HEX ( -- )
                            ;
                            ; Set contents of BASE to sixteen.
                            
                                            WORD    "HEX",NORMAL
        0000C11A          = THIS            .SET    $

Portable National Semiconductor SC/MP Assembler [16.09]

00C11A  03C1              +                 .WORD   LAST
00C11C  00                +                 .BYTE   NORMAL
00C11D  03                +                 .BYTE   STRLEN("HEX")
00C11E  484558            +                 .BYTE   "HEX"
        0000C11A          = LAST            .SET    THIS
                            HEX:            FORTH
00C121  6ED0              +                 .WORD   DO_COLON-1
00C123  74D21000          :                 .WORD   DO_LITERAL,16
00C127  7DC0              :                 .WORD   BASE
00C129  32C1              :                 .WORD   STORE
00C12B  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; Memory Operations
                            ;-------------------------------------------------------------------------------
                            
                            ; ! ( x a-addr -- )
                            ;
                            ; Store x at a-addr.
                            
                                            WORD    "!",NORMAL
        0000C12D          = THIS            .SET    $
00C12D  1AC1              +                 .WORD   LAST
00C12F  00                +                 .BYTE   NORMAL
00C130  01                +                 .BYTE   STRLEN("!")
00C131  21                +                 .BYTE   "!"
        0000C12D          = LAST            .SET    THIS
                            STORE:          NATIVE
00C132  33C1              +                 .WORD   $+1
00C134  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C136  32                :                 XPAL    R1
00C137  C107              :                 LD      SP+1(MA)
00C139  36                :                 XPAH    R1
00C13A  C200              :                 LD      0(R1)           ; Fetch the target address
00C13C  33                :                 XPAL    R2
00C13D  C201              :                 LD      1(R1)
00C13F  37                :                 XPAH    R2
00C140  C202              :                 LD      2(R1)           ; Store the data word
00C142  CB00              :                 ST      0(R2)
00C144  C203              :                 LD      3(R1)
00C146  CB01              :                 ST      1(R2)
00C148  A906              :                 ILD     SP+0(MA)        ; Drop the top two words
00C14A  A906              :                 ILD     SP+0(MA)
00C14C  A906              :                 ILD     SP+0(MA)
00C14E  A906              :                 ILD     SP+0(MA)
                            
00C150  C489              :                 LDI     LO(NEXT-1)      ; Restore R2
00C152  33                :                 XPAL    R2
00C153  C4D0              :                 LDI     HI(NEXT-1)
00C155  37                :                 XPAH    R2
00C156  3F                :                 XPPC    R2              ; And continue
                            
                            ; +! ( n|u a-addr -- )
                            ;

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; Add n|u to the single-cell number at a-addr.
                            
                                            WORD    "+!",NORMAL
        0000C157          = THIS            .SET    $
00C157  2DC1              +                 .WORD   LAST
00C159  00                +                 .BYTE   NORMAL
00C15A  02                +                 .BYTE   STRLEN("+!")
00C15B  2B21              +                 .BYTE   "+!"
        0000C157          = LAST            .SET    THIS
                            PLUS_STORE:     NATIVE
00C15D  5EC1              +                 .WORD   $+1
00C15F  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C161  32                :                 XPAL    R1
00C162  C107              :                 LD      SP+1(MA)
00C164  36                :                 XPAH    R1
00C165  C200              :                 LD      0(R1)           ; Fetch the target address
00C167  33                :                 XPAL    R2
00C168  C201              :                 LD      1(R1)
00C16A  37                :                 XPAH    R2
00C16B  02                :                 CCL
00C16C  C202              :                 LD      2(R1)           ; Add top word to memory
00C16E  F300              :                 ADD     0(R2)
00C170  CB00              :                 ST      0(R2)
00C172  C203              :                 LD      3(R1)
00C174  F301              :                 ADD     1(R2)
00C176  CB01              :                 ST      1(R2)
00C178  A906              :                 ILD     SP+0(MA)        ; Drop the top two words
00C17A  A906              :                 ILD     SP+0(MA)
00C17C  A906              :                 ILD     SP+0(MA)
00C17E  A906              :                 ILD     SP+0(MA)
                            
00C180  C489              :                 LDI     LO(NEXT-1)      ; Restore R2
00C182  33                :                 XPAL    R2
00C183  C4D0              :                 LDI     HI(NEXT-1)
00C185  37                :                 XPAH    R2
00C186  3F                :                 XPPC    R2              ; And continue
                            
                            ; , ( x -- )
                            ;
                            ; Reserve one cell of data space and store x in the cell. If the data-space
                            ; pointer is aligned when , begins execution, it will remain aligned when ,
                            ; finishes execution. An ambiguous condition exists if the data-space pointer
                            ; is not aligned prior to execution of ,.
                            ;
                            ; In this implementation is its defined as:
                            ;
                            ;   HERE ! 1 CELLS ALLOT
                            
                                            WORD    ",",NORMAL
        0000C187          = THIS            .SET    $
00C187  57C1              +                 .WORD   LAST
00C189  00                +                 .BYTE   NORMAL
00C18A  01                +                 .BYTE   STRLEN(",")
00C18B  2C                +                 .BYTE   ","

Portable National Semiconductor SC/MP Assembler [16.09]

        0000C187          = LAST            .SET    THIS
                            COMMA:          FORTH
00C18C  6ED0              +                 .WORD   DO_COLON-1
00C18E  5FC2              :                 .WORD   HERE
00C190  32C1              :                 .WORD   STORE
00C192  74D20100          :                 .WORD   DO_LITERAL,1
00C196  9DC2              :                 .WORD   CELLS
00C198  EFC1              :                 .WORD   ALLOT
00C19A  86CB              :                 .WORD   EXIT
                            
                            ; 2! ( x1 x2 a-addr -- )
                            ;
                            ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
                            ; consecutive cell.
                            ;
                            ; In this implementation is its defined as:
                            ;
                            ;   SWAP OVER ! CELL+ !.
                            
                                            WORD    "2!",NORMAL
        0000C19C          = THIS            .SET    $
00C19C  87C1              +                 .WORD   LAST
00C19E  00                +                 .BYTE   NORMAL
00C19F  02                +                 .BYTE   STRLEN("2!")
00C1A0  3221              +                 .BYTE   "2!"
        0000C19C          = LAST            .SET    THIS
                            TWO_STORE:      FORTH
00C1A2  6ED0              +                 .WORD   DO_COLON-1
00C1A4  E4C3              :                 .WORD   SWAP
00C1A6  87C3              :                 .WORD   OVER
00C1A8  32C1              :                 .WORD   STORE
00C1AA  8AC2              :                 .WORD   CELL_PLUS
00C1AC  32C1              :                 .WORD   STORE
00C1AE  86CB              :                 .WORD   EXIT
                            
                            ; 2@ ( a-addr -- x1 x2 )
                            ;
                            ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
                            ; the next consecutive cell.
                            ;
                            ; In this implementation is its defined as:
                            ;
                            ;   DUP CELL+ @ SWAP @
                            
                                            WORD    "2@",NORMAL
        0000C1B0          = THIS            .SET    $
00C1B0  9CC1              +                 .WORD   LAST
00C1B2  00                +                 .BYTE   NORMAL
00C1B3  02                +                 .BYTE   STRLEN("2@")
00C1B4  3240              +                 .BYTE   "2@"
        0000C1B0          = LAST            .SET    THIS
                            TWO_FETCH:      FORTH
00C1B6  6ED0              +                 .WORD   DO_COLON-1
00C1B8  5DC3              :                 .WORD   DUP

Portable National Semiconductor SC/MP Assembler [16.09]

00C1BA  8AC2              :                 .WORD   CELL_PLUS
00C1BC  C9C1              :                 .WORD   FETCH
00C1BE  E4C3              :                 .WORD   SWAP
00C1C0  C9C1              :                 .WORD   FETCH
00C1C2  86CB              :                 .WORD   EXIT
                            
                            ; @ ( a-addr -- x )
                            ;
                            ; x is the value stored at a-addr.
                            
                                            WORD    "@",NORMAL
        0000C1C4          = THIS            .SET    $
00C1C4  B0C1              +                 .WORD   LAST
00C1C6  00                +                 .BYTE   NORMAL
00C1C7  01                +                 .BYTE   STRLEN("@")
00C1C8  40                +                 .BYTE   "@"
        0000C1C4          = LAST            .SET    THIS
                            FETCH:          NATIVE
00C1C9  CAC1              +                 .WORD   $+1
00C1CB  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C1CD  32                :                 XPAL    R1
00C1CE  C107              :                 LD      SP+1(MA)
00C1D0  36                :                 XPAH    R1
00C1D1  C200              :                 LD      0(R1)           ; Fetch the target address
00C1D3  33                :                 XPAL    R2
00C1D4  C201              :                 LD      1(R1)
00C1D6  37                :                 XPAH    R2
00C1D7  C300              :                 LD      0(R2)           ; Fetch the data word from memory
00C1D9  CA00              :                 ST      0(R1)
00C1DB  C301              :                 LD      1(R2)
00C1DD  CA01              :                 ST      1(R1)
                            
00C1DF  C489              :                 LDI     LO(NEXT-1)      ; Restore R2
00C1E1  33                :                 XPAL    R2
00C1E2  C4D0              :                 LDI     HI(NEXT-1)
00C1E4  37                :                 XPAH    R2
00C1E5  3F                :                 XPPC    R2              ; And continue
                            
                            ; ALLOT ( n -- )
                            ;
                            ; If n is greater than zero, reserve n address units of data space. If n is
                            ; less than zero, release |n| address units of data space. If n is zero, leave
                            ; the data-space pointer unchanged.
                            ;
                            ; In this implementation its is defined as:
                            ;
                            ;   DP +!
                            
                                            WORD    "ALLOT",NORMAL
        0000C1E6          = THIS            .SET    $
00C1E6  C4C1              +                 .WORD   LAST
00C1E8  00                +                 .BYTE   NORMAL
00C1E9  05                +                 .BYTE   STRLEN("ALLOT")
00C1EA  414C4C4F54        +                 .BYTE   "ALLOT"

Portable National Semiconductor SC/MP Assembler [16.09]

        0000C1E6          = LAST            .SET    THIS
                            ALLOT:          FORTH
00C1EF  6ED0              +                 .WORD   DO_COLON-1
00C1F1  96C0              :                 .WORD   DP
00C1F3  5DC1              :                 .WORD   PLUS_STORE
00C1F5  86CB              :                 .WORD   EXIT
                            
                            ; C! ( char c-addr -- )
                            ;
                            ; Store char at c-addr. When character size is smaller than cell size, only the
                            ; number of low-order bits corresponding to character size are transferred.
                            
                                            WORD    "C!",NORMAL
        0000C1F7          = THIS            .SET    $
00C1F7  E6C1              +                 .WORD   LAST
00C1F9  00                +                 .BYTE   NORMAL
00C1FA  02                +                 .BYTE   STRLEN("C!")
00C1FB  4321              +                 .BYTE   "C!"
        0000C1F7          = LAST            .SET    THIS
                            C_STORE:        NATIVE
00C1FD  FEC1              +                 .WORD   $+1
00C1FF  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C201  32                :                 XPAL    R1
00C202  C107              :                 LD      SP+1(MA)
00C204  36                :                 XPAH    R1
00C205  C200              :                 LD      0(R1)           ; Fetch the target address
00C207  33                :                 XPAL    R2
00C208  C201              :                 LD      1(R1)
00C20A  37                :                 XPAH    R2
00C20B  C202              :                 LD      2(R1)           ; Store the data word
00C20D  CB00              :                 ST      0(R2)
00C20F  A906              :                 ILD     SP+0(MA)        ; Drop the top two words
00C211  A906              :                 ILD     SP+0(MA)
00C213  A906              :                 ILD     SP+0(MA)
00C215  A906              :                 ILD     SP+0(MA)
                            
00C217  C489              :                 LDI     LO(NEXT-1)      ; Restore R2
00C219  33                :                 XPAL    R2
00C21A  C4D0              :                 LDI     HI(NEXT-1)
00C21C  37                :                 XPAH    R2
00C21D  3F                :                 XPPC    R2              ; And continue
                            
                            ; C, ( char -- )
                            ;
                            ; Reserve space for one character in the data space and store char in the
                            ; space. If the data-space pointer is character aligned when C, begins
                            ; execution, it will remain character aligned when C, finishes execution.
                            ; An ambiguous condition exists if the data-space pointer is not character-
                            ; aligned prior to execution of C,
                            ;
                            ;   HERE C! 1 CHARS ALLOT
                            
                                            WORD    "C,",NORMAL
        0000C21E          = THIS            .SET    $

Portable National Semiconductor SC/MP Assembler [16.09]

00C21E  F7C1              +                 .WORD   LAST
00C220  00                +                 .BYTE   NORMAL
00C221  02                +                 .BYTE   STRLEN("C,")
00C222  432C              +                 .BYTE   "C,"
        0000C21E          = LAST            .SET    THIS
                            C_COMMA:        FORTH
00C224  6ED0              +                 .WORD   DO_COLON-1
00C226  5FC2              :                 .WORD   HERE
00C228  FDC1              :                 .WORD   C_STORE
00C22A  74D20100          :                 .WORD   DO_LITERAL,1
00C22E  CAC2              :                 .WORD   CHARS
00C230  EFC1              :                 .WORD   ALLOT
00C232  86CB              :                 .WORD   EXIT
                            
                            ; C@ ( c-addr -- char )
                            ;
                            ; Fetch the character stored at c-addr. When the cell size is greater than
                            ; character size, the unused high-order bits are all zeroes.
                            
                                            WORD    "C@",NORMAL
        0000C234          = THIS            .SET    $
00C234  1EC2              +                 .WORD   LAST
00C236  00                +                 .BYTE   NORMAL
00C237  02                +                 .BYTE   STRLEN("C@")
00C238  4340              +                 .BYTE   "C@"
        0000C234          = LAST            .SET    THIS
                            C_FETCH:        NATIVE
00C23A  3BC2              +                 .WORD   $+1
00C23C  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C23E  32                :                 XPAL    R1
00C23F  C107              :                 LD      SP+1(MA)
00C241  36                :                 XPAH    R1
00C242  C200              :                 LD      0(R1)           ; Fetch the target address
00C244  33                :                 XPAL    R2
00C245  C201              :                 LD      1(R1)
00C247  37                :                 XPAH    R2
00C248  C300              :                 LD      0(R2)           ; Fetch the data byte from memory
00C24A  CA00              :                 ST      0(R1)
00C24C  C400              :                 LDI     0
00C24E  CA01              :                 ST      1(R1)
                            
00C250  C489              :                 LDI     LO(NEXT-1)      ; Restore R2
00C252  33                :                 XPAL    R2
00C253  C4D0              :                 LDI     HI(NEXT-1)
00C255  37                :                 XPAH    R2
00C256  3F                :                 XPPC    R2              ; And continue
                            
                            ; HERE ( -- addr )
                            ;
                            ; addr is the data-space pointer.
                            
                                            WORD    "HERE",NORMAL
        0000C257          = THIS            .SET    $
00C257  34C2              +                 .WORD   LAST

Portable National Semiconductor SC/MP Assembler [16.09]

00C259  00                +                 .BYTE   NORMAL
00C25A  04                +                 .BYTE   STRLEN("HERE")
00C25B  48455245          +                 .BYTE   "HERE"
        0000C257          = LAST            .SET    THIS
                            HERE:           FORTH
00C25F  6ED0              +                 .WORD   DO_COLON-1
00C261  96C0              :                 .WORD   DP
00C263  C9C1              :                 .WORD   FETCH
00C265  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; Alignment
                            ;-------------------------------------------------------------------------------
                            
                            ; ALIGN ( -- )
                            ;
                            ; If the data-space pointer is not aligned, reserve enough space to align it.
                            
                                            WORD    "ALIGN",NORMAL
        0000C267          = THIS            .SET    $
00C267  57C2              +                 .WORD   LAST
00C269  00                +                 .BYTE   NORMAL
00C26A  05                +                 .BYTE   STRLEN("ALIGN")
00C26B  414C49474E        +                 .BYTE   "ALIGN"
        0000C267          = LAST            .SET    THIS
                            ALIGN:          NATIVE
00C270  71C2              +                 .WORD   $+1
00C272  3F                :                 XPPC    R2              ; And continue
                            
                            ; ALIGNED ( addr -- a-addr )
                            ;
                            ; a-addr is the first aligned address greater than or equal to addr.
                            
                                            WORD    "ALIGNED",NORMAL
        0000C273          = THIS            .SET    $
00C273  67C2              +                 .WORD   LAST
00C275  00                +                 .BYTE   NORMAL
00C276  07                +                 .BYTE   STRLEN("ALIGNED")
00C277  414C49474E4544    +                 .BYTE   "ALIGNED"
        0000C273          = LAST            .SET    THIS
                            ALIGNED:        NATIVE
00C27E  7FC2              +                 .WORD   $+1
00C280  3F                :                 XPPC    R2              ; And continue
                            
                            ; CELL+ ( a-addr1 -- a-addr2 )
                            ;
                            ; Add the size in address units of a cell to a-addr1, giving a-addr2.
                            
                                            WORD    "CELL+",NORMAL
        0000C281          = THIS            .SET    $
00C281  73C2              +                 .WORD   LAST
00C283  00                +                 .BYTE   NORMAL
00C284  05                +                 .BYTE   STRLEN("CELL+")
00C285  43454C4C2B        +                 .BYTE   "CELL+"

Portable National Semiconductor SC/MP Assembler [16.09]

        0000C281          = LAST            .SET    THIS
                            CELL_PLUS:      FORTH
00C28A  6ED0              +                 .WORD   DO_COLON-1
00C28C  74D20200          :                 .WORD   DO_LITERAL,2
00C290  48C5              :                 .WORD   PLUS
00C292  86CB              :                 .WORD   EXIT
                            
                            ; CELLS ( n1 -- n2 )
                            ;
                            ; n2 is the size in address units of n1 cells.
                            
                                            WORD    "CELLS",NORMAL
        0000C294          = THIS            .SET    $
00C294  81C2              +                 .WORD   LAST
00C296  00                +                 .BYTE   NORMAL
00C297  05                +                 .BYTE   STRLEN("CELLS")
00C298  43454C4C53        +                 .BYTE   "CELLS"
        0000C294          = LAST            .SET    THIS
                            CELLS:          FORTH
00C29D  6ED0              +                 .WORD   DO_COLON-1
00C29F  D0C5              :                 .WORD   TWO_STAR
00C2A1  86CB              :                 .WORD   EXIT
                            
                            ; CHAR+ ( c-addr1 -- c-addr2 )
                            ;
                            ; Add the size in address units of a character to c-addr1, giving c-addr2.
                            
                                            WORD    "CHAR+",NORMAL
        0000C2A3          = THIS            .SET    $
00C2A3  94C2              +                 .WORD   LAST
00C2A5  00                +                 .BYTE   NORMAL
00C2A6  05                +                 .BYTE   STRLEN("CHAR+")
00C2A7  434841522B        +                 .BYTE   "CHAR+"
        0000C2A3          = LAST            .SET    THIS
                            CHAR_PLUS:      FORTH
00C2AC  6ED0              +                 .WORD   DO_COLON-1
00C2AE  B0C5              :                 .WORD   ONE_PLUS
00C2B0  86CB              :                 .WORD   EXIT
                            
                            ; CHAR- ( c-addr1 -- c-addr2 )
                            ;
                            ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
                            
                                            WORD    "CHAR-",NORMAL
        0000C2B2          = THIS            .SET    $
00C2B2  A3C2              +                 .WORD   LAST
00C2B4  00                +                 .BYTE   NORMAL
00C2B5  05                +                 .BYTE   STRLEN("CHAR-")
00C2B6  434841522D        +                 .BYTE   "CHAR-"
        0000C2B2          = LAST            .SET    THIS
                            CHAR_MINUS:     FORTH
00C2BB  6ED0              +                 .WORD   DO_COLON-1
00C2BD  C0C5              :                 .WORD   ONE_MINUS
00C2BF  86CB              :                 .WORD   EXIT

Portable National Semiconductor SC/MP Assembler [16.09]

                            
                            ; CHARS ( n1 -- n2 )
                            ;
                            ; n2 is the size in address units of n1 characters.
                            
                                            WORD    "CHARS",NORMAL
        0000C2C1          = THIS            .SET    $
00C2C1  B2C2              +                 .WORD   LAST
00C2C3  00                +                 .BYTE   NORMAL
00C2C4  05                +                 .BYTE   STRLEN("CHARS")
00C2C5  4348415253        +                 .BYTE   "CHARS"
        0000C2C1          = LAST            .SET    THIS
                            CHARS:          NATIVE
00C2CA  CBC2              +                 .WORD   $+1
00C2CC  3F                :                 XPPC    R2              ; And continue
                            
                            ;===============================================================================
                            ; Stack Operations
                            ;-------------------------------------------------------------------------------
                            
                            ; 2DROP ( x1 x2 -- )
                            ;
                            ; Drop cell pair x1 x2 from the stack.
                            
                                            WORD    "2DROP",NORMAL
        0000C2CD          = THIS            .SET    $
00C2CD  C1C2              +                 .WORD   LAST
00C2CF  00                +                 .BYTE   NORMAL
00C2D0  05                +                 .BYTE   STRLEN("2DROP")
00C2D1  3244524F50        +                 .BYTE   "2DROP"
        0000C2CD          = LAST            .SET    THIS
                            TWO_DROP:       NATIVE
00C2D6  D7C2              +                 .WORD   $+1
00C2D8  A906              :                 ILD     SP+0(MA)        ; Increment the data stack poiner
00C2DA  A906              :                 ILD     SP+0(MA)
00C2DC  A906              :                 ILD     SP+0(MA)
00C2DE  A906              :                 ILD     SP+0(MA)
00C2E0  3F                :                 XPPC    R2              ; And continue
                            
                            ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
                            ;
                            ; Duplicate cell pair x1 x2.
                            
                                            WORD    "2DUP",NORMAL
        0000C2E1          = THIS            .SET    $
00C2E1  CDC2              +                 .WORD   LAST
00C2E3  00                +                 .BYTE   NORMAL
00C2E4  04                +                 .BYTE   STRLEN("2DUP")
00C2E5  32445550          +                 .BYTE   "2DUP"
        0000C2E1          = LAST            .SET    THIS
                            TWO_DUP:        FORTH
00C2E9  6ED0              +                 .WORD   DO_COLON-1
00C2EB  87C3              :                 .WORD   OVER
00C2ED  87C3              :                 .WORD   OVER

Portable National Semiconductor SC/MP Assembler [16.09]

00C2EF  86CB              :                 .WORD   EXIT
                            
                            ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
                            ;
                            ; Copy cell pair x1 x2 to the top of the stack.
                            
                                            WORD    "2OVER",NORMAL
        0000C2F1          = THIS            .SET    $
00C2F1  E1C2              +                 .WORD   LAST
00C2F3  00                +                 .BYTE   NORMAL
00C2F4  05                +                 .BYTE   STRLEN("2OVER")
00C2F5  324F564552        +                 .BYTE   "2OVER"
        0000C2F1          = LAST            .SET    THIS
                            TWO_OVER:       FORTH
00C2FA  6ED0              +                 .WORD   DO_COLON-1
00C2FC  86CB              :                 .WORD   EXIT
                            
                                            ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
                            ;
                            ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
                            ; the top of the stack.
                            
                                            WORD    "2ROT",NORMAL
        0000C2FE          = THIS            .SET    $
00C2FE  F1C2              +                 .WORD   LAST
00C300  00                +                 .BYTE   NORMAL
00C301  04                +                 .BYTE   STRLEN("2ROT")
00C302  32524F54          +                 .BYTE   "2ROT"
        0000C2FE          = LAST            .SET    THIS
                            TWO_ROT:        FORTH
00C306  6ED0              +                 .WORD   DO_COLON-1
00C308  86CB              :                 .WORD   EXIT
                            
                            ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
                            ;
                            ; Exchange the top two cell pairs.
                            
                                            WORD    "2SWAP",NORMAL
        0000C30A          = THIS            .SET    $
00C30A  FEC2              +                 .WORD   LAST
00C30C  00                +                 .BYTE   NORMAL
00C30D  05                +                 .BYTE   STRLEN("2SWAP")
00C30E  3253574150        +                 .BYTE   "2SWAP"
        0000C30A          = LAST            .SET    THIS
                            TWO_SWAP:       FORTH
00C313  6ED0              +                 .WORD   DO_COLON-1
00C315  86CB              :                 .WORD   EXIT
                            
                            ; ?DUP ( x -- 0 | x x )
                            ;
                            ; Duplicate x if it is non-zero.
                            
                                            WORD    "?DUP",NORMAL
        0000C317          = THIS            .SET    $

Portable National Semiconductor SC/MP Assembler [16.09]

00C317  0AC3              +                 .WORD   LAST
00C319  00                +                 .BYTE   NORMAL
00C31A  04                +                 .BYTE   STRLEN("?DUP")
00C31B  3F445550          +                 .BYTE   "?DUP"
        0000C317          = LAST            .SET    THIS
                            QUERY_DUP:      NATIVE
00C31F  20C3              +                 .WORD   $+1
00C321  C106              :                 LD      SP+0(MA)
00C323  32                :                 XPAL    R1
00C324  C107              :                 LD      SP+1(MA)
00C326  36                :                 XPAH    R1
00C327  C200              :                 LD      0(R1)
00C329  DA01              :                 OR      1(R1)
00C32B  9C32              :                 JNZ     DUP+2
00C32D  3F                :                 XPPC    R2
                            
                            ; DEPTH ( -- +n )
                            ;
                            ; +n is the number of single-cell values contained in the data stack before +n
                            ; was placed on the stack.
                            
                                            WORD    "DEPTH",NORMAL
        0000C32E          = THIS            .SET    $
00C32E  17C3              +                 .WORD   LAST
00C330  00                +                 .BYTE   NORMAL
00C331  05                +                 .BYTE   STRLEN("DEPTH")
00C332  4445505448        +                 .BYTE   "DEPTH"
        0000C32E          = LAST            .SET    THIS
                            DEPTH:          FORTH
00C337  6ED0              +                 .WORD   DO_COLON-1
00C339  A0D6              :                 .WORD   AT_DP
00C33B  74D27F10          :                 .WORD   DO_LITERAL,DSTACK_END-1
00C33F  E4C3              :                 .WORD   SWAP
00C341  67C5              :                 .WORD   MINUS
00C343  ECC5              :                 .WORD   TWO_SLASH
00C345  86CB              :                 .WORD   EXIT
                            
                            ; DROP ( x -- )
                            ;
                            ; Remove x from the stack.
                            
                                            WORD    "DROP",NORMAL
        0000C347          = THIS            .SET    $
00C347  2EC3              +                 .WORD   LAST
00C349  00                +                 .BYTE   NORMAL
00C34A  04                +                 .BYTE   STRLEN("DROP")
00C34B  44524F50          +                 .BYTE   "DROP"
        0000C347          = LAST            .SET    THIS
                            DROP:           NATIVE
00C34F  50C3              +                 .WORD   $+1
00C351  A906              :                 ILD     SP+0(MA)        ; Increment the data stack poiner
00C353  A906              :                 ILD     SP+0(MA)
00C355  3F                :                 XPPC    R2              ; And continue
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; DUP ( x -- x x )
                            ;
                            ; Duplicate x.
                            
                                            WORD    "DUP",NORMAL
        0000C356          = THIS            .SET    $
00C356  47C3              +                 .WORD   LAST
00C358  00                +                 .BYTE   NORMAL
00C359  03                +                 .BYTE   STRLEN("DUP")
00C35A  445550            +                 .BYTE   "DUP"
        0000C356          = LAST            .SET    THIS
                            DUP:            NATIVE
00C35D  5EC3              +                 .WORD   $+1
00C35F  B906              :                 DLD     SP+0(MA)        ; Reserved a cell on the stack
00C361  B906              :                 DLD     SP+0(MA)
00C363  32                :                 XPAL    R1
00C364  C107              :                 LD      SP+1(MA)
00C366  36                :                 XPAH    R1
00C367  C202              :                 LD      2(R1)           ; Duplicate the top cell
00C369  CA00              :                 ST      0(R1)
00C36B  C203              :                 LD      3(R1)
00C36D  CA01              :                 ST      1(R1)
00C36F  3F                :                 XPPC    R2
                            
                            ; NIP ( x1 x2 -- x2 )
                            ;
                            ; Drop the first item below the top of stack.
                            
                                            WORD    "NIP",NORMAL
        0000C370          = THIS            .SET    $
00C370  56C3              +                 .WORD   LAST
00C372  00                +                 .BYTE   NORMAL
00C373  03                +                 .BYTE   STRLEN("NIP")
00C374  4E4950            +                 .BYTE   "NIP"
        0000C370          = LAST            .SET    THIS
                            NIP:            FORTH
00C377  6ED0              +                 .WORD   DO_COLON-1
00C379  E4C3              :                 .WORD   SWAP
00C37B  4FC3              :                 .WORD   DROP
00C37D  86CB              :                 .WORD   EXIT
                            
                            ; OVER ( x1 x2 -- x1 x2 x1 )
                            ;
                            ; Place a copy of x1 on top of the stack.
                            
                                            WORD    "OVER",NORMAL
        0000C37F          = THIS            .SET    $
00C37F  70C3              +                 .WORD   LAST
00C381  00                +                 .BYTE   NORMAL
00C382  04                +                 .BYTE   STRLEN("OVER")
00C383  4F564552          +                 .BYTE   "OVER"
        0000C37F          = LAST            .SET    THIS
                            OVER:           NATIVE
00C387  88C3              +                 .WORD   $+1

Portable National Semiconductor SC/MP Assembler [16.09]

00C389  B906              :                 DLD     SP+0(MA)        ; Reserved a cell on the stack
00C38B  B906              :                 DLD     SP+0(MA)
00C38D  32                :                 XPAL    R1
00C38E  C107              :                 LD      SP+1(MA)
00C390  36                :                 XPAH    R1
00C391  C204              :                 LD      4(R1)           ; Duplicate the second cell
00C393  CA00              :                 ST      0(R1)
00C395  C205              :                 LD      5(R1)
00C397  CA01              :                 ST      1(R1)
00C399  3F                :                 XPPC    R2
                            
                            ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
                            ;
                            ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
                            ; if there are less than u+2 items on the stack before PICK is executed.
                            
                                            WORD    "PICK",NORMAL
        0000C39A          = THIS            .SET    $
00C39A  7FC3              +                 .WORD   LAST
00C39C  00                +                 .BYTE   NORMAL
00C39D  04                +                 .BYTE   STRLEN("PICK")
00C39E  5049434B          +                 .BYTE   "PICK"
        0000C39A          = LAST            .SET    THIS
                            PICK:           NATIVE
00C3A2  A3C3              +                 .WORD   $+1
00C3A4  3F                :                 XPPC    R2
                            
                            ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
                            ;
                            ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
                            ; exists if there are less than u+2 items on the stack before ROLL is executed.
                            
                                            WORD    "ROLL",NORMAL
        0000C3A5          = THIS            .SET    $
00C3A5  9AC3              +                 .WORD   LAST
00C3A7  00                +                 .BYTE   NORMAL
00C3A8  04                +                 .BYTE   STRLEN("ROLL")
00C3A9  524F4C4C          +                 .BYTE   "ROLL"
        0000C3A5          = LAST            .SET    THIS
                            ROLL:           NATIVE
00C3AD  AEC3              +                 .WORD   $+1
00C3AF  3F                :                 XPPC    R2
                            
                            ; ROT ( x1 x2 x3 -- x2 x3 x1 )
                            ;
                            ; Rotate the top three stack entries.
                            
                                            WORD    "ROT",NORMAL
        0000C3B0          = THIS            .SET    $
00C3B0  A5C3              +                 .WORD   LAST
00C3B2  00                +                 .BYTE   NORMAL
00C3B3  03                +                 .BYTE   STRLEN("ROT")
00C3B4  524F54            +                 .BYTE   "ROT"
        0000C3B0          = LAST            .SET    THIS

Portable National Semiconductor SC/MP Assembler [16.09]

                            ROT:            NATIVE
00C3B7  B8C3              +                 .WORD   $+1
00C3B9  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C3BB  32                :                 XPAL    R1
00C3BC  C107              :                 LD      SP+1(MA)
00C3BE  36                :                 XPAH    R1
00C3BF  C204              :                 LD      4(R1)           ; Rotate the LSBs
00C3C1  01                :                 XAE
00C3C2  C202              :                 LD      2(R1)
00C3C4  CA04              :                 ST      4(R1)
00C3C6  C200              :                 LD      0(R1)
00C3C8  CA02              :                 ST      2(R1)
00C3CA  40                :                 LDE
00C3CB  CA00              :                 ST      0(R1)
00C3CD  C205              :                 LD      5(R1)           ; Rotate the MSBs
00C3CF  01                :                 XAE
00C3D0  C203              :                 LD      3(R1)
00C3D2  CA05              :                 ST      5(R1)
00C3D4  C201              :                 LD      1(R1)
00C3D6  CA03              :                 ST      3(R1)
00C3D8  40                :                 LDE
00C3D9  CA01              :                 ST      1(R1)
00C3DB  3F                :                 XPPC    R2              ; And continue
                            
                            ; SWAP ( x1 x2 -- x2 x1 )
                            ;
                            ; Exchange the top two stack items.
                            
                                            WORD    "SWAP",NORMAL
        0000C3DC          = THIS            .SET    $
00C3DC  B0C3              +                 .WORD   LAST
00C3DE  00                +                 .BYTE   NORMAL
00C3DF  04                +                 .BYTE   STRLEN("SWAP")
00C3E0  53574150          +                 .BYTE   "SWAP"
        0000C3DC          = LAST            .SET    THIS
                            SWAP:           NATIVE
00C3E4  E5C3              +                 .WORD   $+1
00C3E6  C106              :                 LD      SP+0(MA)        ; Load the stack pointer
00C3E8  32                :                 XPAL    R1
00C3E9  C107              :                 LD      SP+1(MA)
00C3EB  36                :                 XPAH    R1
00C3EC  C200              :                 LD      0(R1)           ; Swap LSBs
00C3EE  01                :                 XAE
00C3EF  C202              :                 LD      2(R1)
00C3F1  CA00              :                 ST      0(R1)
00C3F3  01                :                 XAE
00C3F4  CA02              :                 ST      2(R1)
00C3F6  C201              :                 LD      1(R1)           ; Swap MSBs
00C3F8  01                :                 XAE
00C3F9  C203              :                 LD      3(R1)
00C3FB  CA01              :                 ST      1(R1)
00C3FD  01                :                 XAE
00C3FE  CA03              :                 ST      3(R1)
00C400  3F                :                 XPPC    R2              ; And continue

Portable National Semiconductor SC/MP Assembler [16.09]

                            
                            ; TUCK ( x1 x2 -- x2 x1 x2 )
                            ;
                            ; Copy the first (top) stack item below the second stack item.
                            
                                            WORD    "TUCK",NORMAL
        0000C401          = THIS            .SET    $
00C401  DCC3              +                 .WORD   LAST
00C403  00                +                 .BYTE   NORMAL
00C404  04                +                 .BYTE   STRLEN("TUCK")
00C405  5455434B          +                 .BYTE   "TUCK"
        0000C401          = LAST            .SET    THIS
                            TUCK:           FORTH
00C409  6ED0              +                 .WORD   DO_COLON-1
00C40B  E4C3              :                 .WORD   SWAP
00C40D  87C3              :                 .WORD   OVER
00C40F  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; Return Stack Operations
                            ;-------------------------------------------------------------------------------
                            
                            ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
                            ;
                            ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
                            ; SWAP >R >R.
                            
                                            WORD    "2>R",NORMAL
        0000C411          = THIS            .SET    $
00C411  01C4              +                 .WORD   LAST
00C413  00                +                 .BYTE   NORMAL
00C414  03                +                 .BYTE   STRLEN("2>R")
00C415  323E52            +                 .BYTE   "2>R"
        0000C411          = LAST            .SET    THIS
                            TWO_TO_R:       FORTH
00C418  6ED0              +                 .WORD   DO_COLON-1
00C41A  E4C3              :                 .WORD   SWAP
00C41C  52C4              :                 .WORD   TO_R
00C41E  52C4              :                 .WORD   TO_R
00C420  86CB              :                 .WORD   EXIT
                            
                            ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
                            ;
                            ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
                            ; R> SWAP.
                            
                                            WORD    "2R>",NORMAL
        0000C422          = THIS            .SET    $
00C422  11C4              +                 .WORD   LAST
00C424  00                +                 .BYTE   NORMAL
00C425  03                +                 .BYTE   STRLEN("2R>")
00C426  32523E            +                 .BYTE   "2R>"
        0000C422          = LAST            .SET    THIS
                            TWO_R_FROM:     FORTH

Portable National Semiconductor SC/MP Assembler [16.09]

00C429  6ED0              +                 .WORD   DO_COLON-1
00C42B  C3C4              :                 .WORD   R_FROM
00C42D  C3C4              :                 .WORD   R_FROM
00C42F  E4C3              :                 .WORD   SWAP
00C431  86CB              :                 .WORD   EXIT
                            
                            ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
                            ;
                            ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
                            ; 2DUP >R >R SWAP.
                            
                                            WORD    "2R@",NORMAL
        0000C433          = THIS            .SET    $
00C433  22C4              +                 .WORD   LAST
00C435  00                +                 .BYTE   NORMAL
00C436  03                +                 .BYTE   STRLEN("2R@")
00C437  325240            +                 .BYTE   "2R@"
        0000C433          = LAST            .SET    THIS
                            TWO_R_FETCH:    FORTH
00C43A  6ED0              +                 .WORD   DO_COLON-1
00C43C  C3C4              :                 .WORD   R_FROM
00C43E  C3C4              :                 .WORD   R_FROM
00C440  87C3              :                 .WORD   OVER
00C442  87C3              :                 .WORD   OVER
00C444  52C4              :                 .WORD   TO_R
00C446  52C4              :                 .WORD   TO_R
00C448  E4C3              :                 .WORD   SWAP
00C44A  86CB              :                 .WORD   EXIT
                            
                            ; >R ( x -- ) ( R: -- x )
                            ;
                            ; Move x to the return stack.
                            
                                            WORD    ">R",NORMAL
        0000C44C          = THIS            .SET    $
00C44C  33C4              +                 .WORD   LAST
00C44E  00                +                 .BYTE   NORMAL
00C44F  02                +                 .BYTE   STRLEN(">R")
00C450  3E52              +                 .BYTE   ">R"
        0000C44C          = LAST            .SET    THIS
                            TO_R:           NATIVE
00C452  53C4              +                 .WORD   $+1
00C454  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C456  32                :                 XPAL    R1
00C457  C107              :                 LD      SP+1(MA)
00C459  36                :                 XPAH    R1
00C45A  B904              :                 DLD     RP+0(MA)        ; Reserve a cell on the return stack
00C45C  B904              :                 DLD     RP+0(MA)        ; .. and load the pointer
00C45E  33                :                 XPAL    R2
00C45F  C105              :                 LD      RP+1(MA)
00C461  37                :                 XPAH    R2
00C462  C200              :                 LD      0(R1)           ; Tranfer a word across
00C464  CB00              :                 ST      0(R2)
00C466  C201              :                 LD      1(R1)

Portable National Semiconductor SC/MP Assembler [16.09]

00C468  CB01              :                 ST      1(R2)
00C46A  A906              :                 ILD     SP+0(MA)        ; Drop cell from data stack
00C46C  A906              :                 ILD     SP+0(MA)
                            
00C46E  C489              :                 LDI     LO(NEXT-1)      ; Restore the NEXT pointer
00C470  33                :                 XPAL    R2
00C471  C4D0              :                 LDI     HI(NEXT-1)
00C473  33                :                 XPAL    R2
00C474  3F                :                 XPPC    R2              ; All done
                            
                            ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
                            ;
                            ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
                            ; exists if the loop control parameters are unavailable.
                            
                                            WORD    "I",NORMAL
        0000C475          = THIS            .SET    $
00C475  4CC4              +                 .WORD   LAST
00C477  00                +                 .BYTE   NORMAL
00C478  01                +                 .BYTE   STRLEN("I")
00C479  49                +                 .BYTE   "I"
        0000C475          = LAST            .SET    THIS
                            I:              NATIVE
00C47A  7BC4              +                 .WORD   $+1
00C47C  B906              :                 DLD     SP+0(MA)        ; Reserve a cell in the data stack
00C47E  B906              :                 DLD     SP+0(MA)        ; .. and load the pointer
00C480  32                :                 XPAL    R1
00C481  C107              :                 LD      SP+1(MA)
00C483  36                :                 XPAH    R1
00C484  C104              :                 LD      RP+0(MA)        ; Load the return stack pointer
00C486  33                :                 XPAL    R2
00C487  C105              :                 LD      RP+1(MA)
00C489  37                :                 XPAH    R2
00C48A  C300              :                 LD      0(R2)           ; Copy the inner loop counter
00C48C  CA00              :                 ST      0(R1)
00C48E  C301              :                 LD      1(R2)
00C490  CA01              :                 ST      1(R1)
00C492  C489              :                 LDI     LO(NEXT-1)      ; Restore the NEXT pointer
00C494  33                :                 XPAL    R2
00C495  C4D0              :                 LDI     HI(NEXT-1)
00C497  33                :                 XPAL    R2
00C498  3F                :                 XPPC    R2              ; And continue
                            
                            ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
                            ;
                            ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
                            ; the loop control parameters of the next-outer loop, loop-sys1, are
                            ; unavailable.
                            
                                            WORD    "J",NORMAL
        0000C499          = THIS            .SET    $
00C499  75C4              +                 .WORD   LAST
00C49B  00                +                 .BYTE   NORMAL
00C49C  01                +                 .BYTE   STRLEN("J")

Portable National Semiconductor SC/MP Assembler [16.09]

00C49D  4A                +                 .BYTE   "J"
        0000C499          = LAST            .SET    THIS
                            J:              NATIVE
00C49E  9FC4              +                 .WORD   $+1
00C4A0  B906              :                 DLD     SP+0(MA)        ; Reserve a cell in the data stack
00C4A2  B906              :                 DLD     SP+0(MA)        ; .. and load the pointer
00C4A4  32                :                 XPAL    R1
00C4A5  C107              :                 LD      SP+1(MA)
00C4A7  36                :                 XPAH    R1
00C4A8  C104              :                 LD      RP+0(MA)        ; Load the return stack pointer
00C4AA  33                :                 XPAL    R2
00C4AB  C105              :                 LD      RP+1(MA)
00C4AD  37                :                 XPAH    R2
00C4AE  C304              :                 LD      4(R2)           ; Copy the outer loop counter
00C4B0  CA00              :                 ST      0(R1)
00C4B2  C305              :                 LD      5(R2)
00C4B4  CA01              :                 ST      1(R1)
00C4B6  C489              :                 LDI     LO(NEXT-1)      ; Restore the NEXT pointer
00C4B8  33                :                 XPAL    R2
00C4B9  C4D0              :                 LDI     HI(NEXT-1)
00C4BB  33                :                 XPAL    R2
00C4BC  3F                :                 XPPC    R2              ; And continue
                            
                            ; R> ( -- x ) ( R: x -- )
                            ;
                            ; Move x from the return stack to the data stack.
                            
                                            WORD    "R>",NORMAL
        0000C4BD          = THIS            .SET    $
00C4BD  99C4              +                 .WORD   LAST
00C4BF  00                +                 .BYTE   NORMAL
00C4C0  02                +                 .BYTE   STRLEN("R>")
00C4C1  523E              +                 .BYTE   "R>"
        0000C4BD          = LAST            .SET    THIS
                            R_FROM:         NATIVE
00C4C3  C4C4              +                 .WORD   $+1
00C4C5  B906              :                 DLD     SP+0(MA)        ; Reserve a cell in the data stack
00C4C7  B906              :                 DLD     SP+0(MA)        ; .. and load the pointer
00C4C9  32                :                 XPAL    R1
00C4CA  C107              :                 LD      SP+1(MA)
00C4CC  36                :                 XPAH    R1
00C4CD  C104              :                 LD      RP+0(MA)        ; Load the return stack pointer
00C4CF  33                :                 XPAL    R2
00C4D0  C105              :                 LD      RP+1(MA)
00C4D2  37                :                 XPAH    R2
00C4D3  C300              :                 LD      0(R2)           ; Copy the top cell
00C4D5  CA00              :                 ST      0(R1)
00C4D7  C301              :                 LD      1(R2)
00C4D9  CA01              :                 ST      1(R1)
00C4DB  A904              :                 ILD     RP+0(MA)        ; Drop cell from return stack
00C4DD  A905              :                 ILD     RP+1(MA)
00C4DF  C489              :                 LDI     LO(NEXT-1)      ; Restore the NEXT pointer
00C4E1  33                :                 XPAL    R2
00C4E2  C4D0              :                 LDI     HI(NEXT-1)

Portable National Semiconductor SC/MP Assembler [16.09]

00C4E4  33                :                 XPAL    R2
00C4E5  3F                :                 XPPC    R2              ; And continue
                            
                            ; R@ ( -- x ) ( R: x -- x )
                            ;
                            ; Copy x from the return stack to the data stack.
                            
                                            WORD    "R@",NORMAL
        0000C4E6          = THIS            .SET    $
00C4E6  BDC4              +                 .WORD   LAST
00C4E8  00                +                 .BYTE   NORMAL
00C4E9  02                +                 .BYTE   STRLEN("R@")
00C4EA  5240              +                 .BYTE   "R@"
        0000C4E6          = LAST            .SET    THIS
                            R_FETCH:        NATIVE
00C4EC  EDC4              +                 .WORD   $+1
00C4EE  B906              :                 DLD     SP+0(MA)        ; Reserve a cell in the data stack
00C4F0  B906              :                 DLD     SP+0(MA)        ; .. and load the pointer
00C4F2  32                :                 XPAL    R1
00C4F3  C107              :                 LD      SP+1(MA)
00C4F5  36                :                 XPAH    R1
00C4F6  C104              :                 LD      RP+0(MA)        ; Load the return stack pointer
00C4F8  33                :                 XPAL    R2
00C4F9  C105              :                 LD      RP+1(MA)
00C4FB  37                :                 XPAH    R2
00C4FC  C300              :                 LD      0(R2)           ; Copy the top cell
00C4FE  CA00              :                 ST      0(R1)
00C500  C301              :                 LD      1(R2)
00C502  CA01              :                 ST      1(R1)
00C504  C489              :                 LDI     LO(NEXT-1)      ; Restore the NEXT pointer
00C506  33                :                 XPAL    R2
00C507  C4D0              :                 LDI     HI(NEXT-1)
00C509  33                :                 XPAL    R2
00C50A  3F                :                 XPPC    R2              ; And continue
                            
                            ;===============================================================================
                            ; Single Precision Arithmetic
                            ;-------------------------------------------------------------------------------
                            
                            ; * ( n1|u1 n2|u2 -- n3|u3 )
                            ;
                            ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   M* DROP
                            
                                            WORD    "*",NORMAL
        0000C50B          = THIS            .SET    $
00C50B  E6C4              +                 .WORD   LAST
00C50D  00                +                 .BYTE   NORMAL
00C50E  01                +                 .BYTE   STRLEN("*")
00C50F  2A                +                 .BYTE   "*"
        0000C50B          = LAST            .SET    THIS

Portable National Semiconductor SC/MP Assembler [16.09]

                            STAR:           FORTH
00C510  6ED0              +                 .WORD   DO_COLON-1
00C512  B0C8              :                 .WORD   M_STAR
00C514  4FC3              :                 .WORD   DROP
00C516  86CB              :                 .WORD   EXIT
                            
                            ; */ ( n1 n2 n3 -- n4 )
                            ;
                            ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
                            ; by n3 giving the single-cell quotient n4. An ambiguous condition exists if
                            ; n3 is zero or if the quotient n4 lies outside the range of a signed number.
                            ; If d and n3 differ in sign, the implementation-defined result returned will
                            ; be the same as that returned by either the phrase >R M* R> FM/MOD SWAP DROP
                            ; or the phrase >R M* R> SM/REM SWAP DROP.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   >R M* R> FM/MOD SWAP DROP
                            
                                            WORD    "*/",NORMAL
        0000C518          = THIS            .SET    $
00C518  0BC5              +                 .WORD   LAST
00C51A  00                +                 .BYTE   NORMAL
00C51B  02                +                 .BYTE   STRLEN("*/")
00C51C  2A2F              +                 .BYTE   "*/"
        0000C518          = LAST            .SET    THIS
                            STAR_SLASH:     FORTH
00C51E  6ED0              +                 .WORD   DO_COLON-1
00C520  52C4              :                 .WORD   TO_R
00C522  B0C8              :                 .WORD   M_STAR
00C524  C3C4              :                 .WORD   R_FROM
00C526  2FC6              :                 .WORD   FM_SLASH_MOD
00C528  E4C3              :                 .WORD   SWAP
00C52A  4FC3              :                 .WORD   DROP
00C52C  86CB              :                 .WORD   EXIT
                            
                            ; */MOD ( n1 n2 n3 -- n4 n5 )
                            ;
                            ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
                            ; by n3 producing the single-cell remainder n4 and the single-cell quotient n5.
                            ; An ambiguous condition exists if n3 is zero, or if the quotient n5 lies
                            ; outside the range of a single-cell signed integer. If d and n3 differ in
                            ; sign, the implementation-defined result returned will be the same as that
                            ; returned by either the phrase >R M* R> FM/MOD or the phrase >R M* R> SM/REM.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   >R M* R> FM/MOD
                            
                                            WORD    "*/MOD",NORMAL
        0000C52E          = THIS            .SET    $
00C52E  18C5              +                 .WORD   LAST
00C530  00                +                 .BYTE   NORMAL
00C531  05                +                 .BYTE   STRLEN("*/MOD")

Portable National Semiconductor SC/MP Assembler [16.09]

00C532  2A2F4D4F44        +                 .BYTE   "*/MOD"
        0000C52E          = LAST            .SET    THIS
                            STAR_SLASH_MOD: FORTH
00C537  6ED0              +                 .WORD   DO_COLON-1
00C539  52C4              :                 .WORD   TO_R
00C53B  B0C8              :                 .WORD   M_STAR
00C53D  C3C4              :                 .WORD   R_FROM
00C53F  2FC6              :                 .WORD   FM_SLASH_MOD
00C541  86CB              :                 .WORD   EXIT
                            
                            ; + ( n1|u1 n2|u2 -- n3|u3 )
                            ;
                            ; Add n2|u2 to n1|u1, giving the sum n3|u3.
                            
                                            WORD    "+",NORMAL
        0000C543          = THIS            .SET    $
00C543  2EC5              +                 .WORD   LAST
00C545  00                +                 .BYTE   NORMAL
00C546  01                +                 .BYTE   STRLEN("+")
00C547  2B                +                 .BYTE   "+"
        0000C543          = LAST            .SET    THIS
                            PLUS:           NATIVE
00C548  49C5              +                 .WORD   $+1
00C54A  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C54C  32                :                 XPAL    R1
00C54D  C107              :                 LD      SP+1(MA)
00C54F  36                :                 XPAH    R1
00C550  02                :                 CCL                     ; Add the top two cells
00C551  C202              :                 LD      2(R1)
00C553  F200              :                 ADD     0(R1)
00C555  CA02              :                 ST      2(R1)
00C557  C203              :                 LD      3(R1)
00C559  F202              :                 ADD     2(R1)
00C55B  CA03              :                 ST      3(R1)
00C55D  A906              :                 ILD     SP+0(MA)        ; Drop the top cell
00C55F  A907              :                 ILD     SP+1(MA)
00C561  3F                :                 XPPC    R2              ; And continue
                            
                            ; - ( n1|u1 n2|u2 -- n3|u3 )
                            ;
                            ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
                            
                                            WORD    "-",NORMAL
        0000C562          = THIS            .SET    $
00C562  43C5              +                 .WORD   LAST
00C564  00                +                 .BYTE   NORMAL
00C565  01                +                 .BYTE   STRLEN("-")
00C566  2D                +                 .BYTE   "-"
        0000C562          = LAST            .SET    THIS
                            MINUS:          NATIVE
00C567  68C5              +                 .WORD   $+1
00C569  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C56B  32                :                 XPAL    R1
00C56C  C107              :                 LD      SP+1(MA)

Portable National Semiconductor SC/MP Assembler [16.09]

00C56E  36                :                 XPAH    R1
00C56F  03                :                 SCL                     ; Add the top two cells
00C570  C202              :                 LD      2(R1)
00C572  FA00              :                 CAD     0(R1)
00C574  CA02              :                 ST      2(R1)
00C576  C203              :                 LD      3(R1)
00C578  FA01              :                 CAD     1(R1)
00C57A  CA03              :                 ST      3(R1)
00C57C  A906              :                 ILD     SP+0(MA)        ; Drop the top cell
00C57E  A907              :                 ILD     SP+1(MA)
00C580  3F                :                 XPPC    R2              ; And continue
                            
                            ; / ( n1 n2 -- n3 )
                            ;
                            ; Divide n1 by n2, giving the single-cell quotient n3. An ambiguous condition
                            ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
                            ; result returned will be the same as that returned by either the phrase >R S>D
                            ; R> FM/MOD SWAP DROP or the phrase >R S>D R> SM/REM SWAP DROP.
                            ;
                            ; In this implementatio it is defined as:
                            ;
                            ;   >R S>D R> FM/MOD SWAP DROP
                            
                                            WORD    "/",NORMAL
        0000C581          = THIS            .SET    $
00C581  62C5              +                 .WORD   LAST
00C583  00                +                 .BYTE   NORMAL
00C584  01                +                 .BYTE   STRLEN("/")
00C585  2F                +                 .BYTE   "/"
        0000C581          = LAST            .SET    THIS
                            SLASH:          FORTH
00C586  6ED0              +                 .WORD   DO_COLON-1
00C588  52C4              :                 .WORD   TO_R
00C58A  FBC8              :                 .WORD   S_TO_D
00C58C  C3C4              :                 .WORD   R_FROM
00C58E  2FC6              :                 .WORD   FM_SLASH_MOD
00C590  E4C3              :                 .WORD   SWAP
00C592  4FC3              :                 .WORD   DROP
00C594  86CB              :                 .WORD   EXIT
                            
                            ; /MOD ( n1 n2 -- n3 n4 )
                            ;
                            ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
                            ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
                            ; in sign, the implementation-defined result returned will be the same as that
                            ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   >R S>D R> FM/MOD
                            
                                            WORD    "/MOD",NORMAL
        0000C596          = THIS            .SET    $
00C596  81C5              +                 .WORD   LAST

Portable National Semiconductor SC/MP Assembler [16.09]

00C598  00                +                 .BYTE   NORMAL
00C599  04                +                 .BYTE   STRLEN("/MOD")
00C59A  2F4D4F44          +                 .BYTE   "/MOD"
        0000C596          = LAST            .SET    THIS
                            SLASH_MOD:      FORTH
00C59E  6ED0              +                 .WORD   DO_COLON-1
00C5A0  52C4              :                 .WORD   TO_R
00C5A2  FBC8              :                 .WORD   S_TO_D
00C5A4  C3C4              :                 .WORD   R_FROM
00C5A6  2FC6              :                 .WORD   FM_SLASH_MOD
00C5A8  86CB              :                 .WORD   EXIT
                            
                            ; 1+ ( n1|u1 -- n2|u2 )
                            ;
                            ; Add one (1) to n1|u1 giving the sum n2|u2.
                            
                                            WORD    "1+",NORMAL
        0000C5AA          = THIS            .SET    $
00C5AA  96C5              +                 .WORD   LAST
00C5AC  00                +                 .BYTE   NORMAL
00C5AD  02                +                 .BYTE   STRLEN("1+")
00C5AE  312B              +                 .BYTE   "1+"
        0000C5AA          = LAST            .SET    THIS
                            ONE_PLUS:       FORTH
00C5B0  6ED0              +                 .WORD   DO_COLON-1
00C5B2  74D20100          :                 .WORD   DO_LITERAL,1
00C5B6  48C5              :                 .WORD   PLUS
00C5B8  86CB              :                 .WORD   EXIT
                            
                            ; 1- ( n1|u1 -- n2|u2 )
                            ;
                            ; Subtract one (1) from n1|u1 giving the difference n2|u2.
                            
                                            WORD    "1-",NORMAL
        0000C5BA          = THIS            .SET    $
00C5BA  AAC5              +                 .WORD   LAST
00C5BC  00                +                 .BYTE   NORMAL
00C5BD  02                +                 .BYTE   STRLEN("1-")
00C5BE  312D              +                 .BYTE   "1-"
        0000C5BA          = LAST            .SET    THIS
                            ONE_MINUS:      FORTH
00C5C0  6ED0              +                 .WORD   DO_COLON-1
00C5C2  74D20100          :                 .WORD   DO_LITERAL,1
00C5C6  67C5              :                 .WORD   MINUS
00C5C8  86CB              :                 .WORD   EXIT
                            
                            ; 2* ( x1 -- x2 )
                            ;
                            ; x2 is the result of shifting x1 one bit toward the most-significant bit,
                            ; filling the vacated least-significant bit with zero.
                            
                                            WORD    "2*",NORMAL
        0000C5CA          = THIS            .SET    $
00C5CA  BAC5              +                 .WORD   LAST

Portable National Semiconductor SC/MP Assembler [16.09]

00C5CC  00                +                 .BYTE   NORMAL
00C5CD  02                +                 .BYTE   STRLEN("2*")
00C5CE  322A              +                 .BYTE   "2*"
        0000C5CA          = LAST            .SET    THIS
                            TWO_STAR:       NATIVE
00C5D0  D1C5              +                 .WORD   $+1
00C5D2  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C5D4  32                :                 XPAL    R1
00C5D5  C107              :                 LD      SP+1(MA)
00C5D7  36                :                 XPAH    R1
00C5D8  02                :                 CCL                     ; Add top of stack to itself
00C5D9  C200              :                 LD      0(R1)
00C5DB  F200              :                 ADD     0(R1)
00C5DD  CA00              :                 ST      0(R1)
00C5DF  C201              :                 LD      1(R1)
00C5E1  F201              :                 ADD     1(R1)
00C5E3  CA01              :                 ST      1(R1)
00C5E5  3F                :                 XPPC    R2              ; And continue
                            
                            ; 2/ ( x1 -- x2 )
                            ;
                            ; x2 is the result of shifting x1 one bit toward the least-significant bit,
                            ; leaving the most-significant bit unchanged.
                            
                                            WORD    "2/",NORMAL
        0000C5E6          = THIS            .SET    $
00C5E6  CAC5              +                 .WORD   LAST
00C5E8  00                +                 .BYTE   NORMAL
00C5E9  02                +                 .BYTE   STRLEN("2/")
00C5EA  322F              +                 .BYTE   "2/"
        0000C5E6          = LAST            .SET    THIS
                            TWO_SLASH:      NATIVE
00C5EC  EDC5              +                 .WORD   $+1
00C5EE  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C5F0  32                :                 XPAL    R1
00C5F1  C107              :                 LD      SP+1(MA)
00C5F3  36                :                 XPAH    R1
00C5F4  02                :                 CCL                     ; Shift MSB into carry
00C5F5  C201              :                 LD      1(R1)
00C5F7  F201              :                 ADD     1(R1)
00C5F9  C201              :                 LD      1(R1)           ; Then rotate cell right
00C5FB  1F                :                 RRL
00C5FC  CA01              :                 ST      1(R1)
00C5FE  C200              :                 LD      0(R1)
00C600  1F                :                 RRL
00C601  CA00              :                 ST      0(R1)
00C603  3F                :                 XPPC    R2              ; And continue
                            
                            ; ?NEGATE ( x sign -- x/-x)
                            ;
                            ; If the sign value is negative then negate the value of x to match.
                            ;
                            ; In this implementation it is defined as:
                            ;

Portable National Semiconductor SC/MP Assembler [16.09]

                            ;   0< IF NEGATE THEN
                            
                            QUERY_NEGATE:   FORTH
00C604  6ED0              +                 .WORD   DO_COLON-1
00C606  6BC9              :                 .WORD   ZERO_LESS
00C608  10D20EC6          :                 .WORD   QUERY_BRANCH,.SKIP
00C60C  BAC6              :                 .WORD   NEGATE
00C60E  86CB              : .SKIP           .WORD   EXIT
                            
                            ; ABS ( n -- u )
                            ;
                            ; u is the absolute value of n.
                            
                                            WORD    "ABS",NORMAL
        0000C610          = THIS            .SET    $
00C610  E6C5              +                 .WORD   LAST
00C612  00                +                 .BYTE   NORMAL
00C613  03                +                 .BYTE   STRLEN("ABS")
00C614  414253            +                 .BYTE   "ABS"
        0000C610          = LAST            .SET    THIS
                            ABS:            FORTH
00C617  6ED0              +                 .WORD   DO_COLON-1
00C619  5DC3              :                 .WORD   DUP
00C61B  6BC9              :                 .WORD   ZERO_LESS
00C61D  10D223C6          :                 .WORD   QUERY_BRANCH,.SKIP
00C621  BAC6              :                 .WORD   NEGATE
00C623  86CB              : .SKIP           .WORD   EXIT
                            
                            ; FM/MOD ( n1 n2 -- n3 n4 )
                            ;
                            ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
                            ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
                            ; in sign, the implementation-defined result returned will be the same as that
                            ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   DUP >R                      divisor
                            ;   2DUP XOR >R                 sign of quotient
                            ;   >R                          divisor
                            ;   DABS R@ ABS UM/MOD
                            ;   SWAP R> ?NEGATE SWAP        apply sign to remainder
                            ;   R> 0< IF                    if quotient negative,
                            ;       NEGATE
                            ;       OVER IF                 if remainder nonzero,
                            ;       R@ ROT - SWAP 1-        adjust rem,quot
                            ;       THEN
                            ;   THEN  R> DROP ;
                            
                                            WORD    "FM/MOD",NORMAL
        0000C625          = THIS            .SET    $
00C625  10C6              +                 .WORD   LAST
00C627  00                +                 .BYTE   NORMAL
00C628  06                +                 .BYTE   STRLEN("FM/MOD")

Portable National Semiconductor SC/MP Assembler [16.09]

00C629  464D2F4D4F44      +                 .BYTE   "FM/MOD"
        0000C625          = LAST            .SET    THIS
                            FM_SLASH_MOD:   FORTH
00C62F  6ED0              +                 .WORD   DO_COLON-1
00C631  5DC3              :                 .WORD   DUP
00C633  52C4              :                 .WORD   TO_R
00C635  E9C2              :                 .WORD   TWO_DUP
00C637  E3CA              :                 .WORD   XOR
00C639  52C4              :                 .WORD   TO_R
00C63B  52C4              :                 .WORD   TO_R
00C63D  2BC8              :                 .WORD   DABS
00C63F  ECC4              :                 .WORD   R_FETCH
00C641  17C6              :                 .WORD   ABS
00C643  62C9              :                 .WORD   UM_SLASH_MOD
00C645  E4C3              :                 .WORD   SWAP
00C647  C3C4              :                 .WORD   R_FROM
00C649  04C6              :                 .WORD   QUERY_NEGATE
00C64B  E4C3              :                 .WORD   SWAP
00C64D  C3C4              :                 .WORD   R_FROM
00C64F  6BC9              :                 .WORD   ZERO_LESS
00C651  10D267C6          :                 .WORD   QUERY_BRANCH,.SKIP
00C655  BAC6              :                 .WORD   NEGATE
00C657  87C3              :                 .WORD   OVER
00C659  10D267C6          :                 .WORD   QUERY_BRANCH,.SKIP
00C65D  ECC4              :                 .WORD   R_FETCH
00C65F  B7C3              :                 .WORD   ROT
00C661  67C5              :                 .WORD   MINUS
00C663  E4C3              :                 .WORD   SWAP
00C665  C0C5              :                 .WORD   ONE_MINUS
00C667  C3C4              : .SKIP           .WORD   R_FROM
00C669  4FC3              :                 .WORD   DROP
00C66B  86CB              :                 .WORD   EXIT
                            
                            ; MAX ( n1 n2 -- n3 )
                            ;
                            ; n3 is the greater of n1 and n2.
                            
                                            WORD    "MAX",NORMAL
        0000C66D          = THIS            .SET    $
00C66D  25C6              +                 .WORD   LAST
00C66F  00                +                 .BYTE   NORMAL
00C670  03                +                 .BYTE   STRLEN("MAX")
00C671  4D4158            +                 .BYTE   "MAX"
        0000C66D          = LAST            .SET    THIS
                            MAX:            FORTH
00C674  6ED0              +                 .WORD   DO_COLON-1
00C676  E9C2              :                 .WORD   TWO_DUP
00C678  D7C9              :                 .WORD   LESS
00C67A  10D280C6          :                 .WORD   QUERY_BRANCH,.SKIP
00C67E  E4C3              :                 .WORD   SWAP
00C680  4FC3              : .SKIP           .WORD   DROP
00C682  86CB              :                 .WORD   EXIT
                            
                            ; MIN ( n1 n2 -- n3 )

Portable National Semiconductor SC/MP Assembler [16.09]

                            ;
                            ; n3 is the lesser of n1 and n2.
                            
                                            WORD    "MIN",NORMAL
        0000C684          = THIS            .SET    $
00C684  6DC6              +                 .WORD   LAST
00C686  00                +                 .BYTE   NORMAL
00C687  03                +                 .BYTE   STRLEN("MIN")
00C688  4D494E            +                 .BYTE   "MIN"
        0000C684          = LAST            .SET    THIS
                            MIN:            FORTH
00C68B  6ED0              +                 .WORD   DO_COLON-1
00C68D  E9C2              :                 .WORD   TWO_DUP
00C68F  01CA              :                 .WORD   GREATER
00C691  10D297C6          :                 .WORD   QUERY_BRANCH,.SKIP
00C695  E4C3              :                 .WORD   SWAP
00C697  4FC3              : .SKIP           .WORD   DROP
00C699  86CB              :                 .WORD   EXIT
                            
                            ; MOD ( n1 n2 -- n3 )
                            ;
                            ; Divide n1 by n2, giving the single-cell remainder n3. An ambiguous condition
                            ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
                            ; result returned will be the same as that returned by either the phrase >R S>D
                            ; R> FM/MOD DROP or the phrase >R S>D R> SM/REM DROP.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   >R S>D R> FM/MOD DROP
                            
                                            WORD    "MOD",NORMAL
        0000C69B          = THIS            .SET    $
00C69B  84C6              +                 .WORD   LAST
00C69D  00                +                 .BYTE   NORMAL
00C69E  03                +                 .BYTE   STRLEN("MOD")
00C69F  4D4F44            +                 .BYTE   "MOD"
        0000C69B          = LAST            .SET    THIS
                            MOD:            FORTH
00C6A2  6ED0              +                 .WORD   DO_COLON-1
00C6A4  52C4              :                 .WORD   TO_R
00C6A6  FBC8              :                 .WORD   S_TO_D
00C6A8  C3C4              :                 .WORD   R_FROM
00C6AA  2FC6              :                 .WORD   FM_SLASH_MOD
00C6AC  4FC3              :                 .WORD   DROP
00C6AE  86CB              :                 .WORD   EXIT
                            
                            ; NEGATE ( n1 -- n2 )
                            ;
                            ; Negate n1, giving its arithmetic inverse n2.
                            
                                            WORD    "NEGATE",NORMAL
        0000C6B0          = THIS            .SET    $
00C6B0  9BC6              +                 .WORD   LAST
00C6B2  00                +                 .BYTE   NORMAL

Portable National Semiconductor SC/MP Assembler [16.09]

00C6B3  06                +                 .BYTE   STRLEN("NEGATE")
00C6B4  4E4547415445      +                 .BYTE   "NEGATE"
        0000C6B0          = LAST            .SET    THIS
                            NEGATE:         NATIVE
00C6BA  BBC6              +                 .WORD   $+1
00C6BC  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C6BE  32                :                 XPAL    R1
00C6BF  C107              :                 LD      SP+1(MA)
00C6C1  36                :                 XPAH    R1
00C6C2  03                :                 SCL                     ; Negate the top word
00C6C3  C400              :                 LDI     0
00C6C5  FA00              :                 CAD     0(R1)
00C6C7  CA00              :                 ST      0(R1)
00C6C9  C400              :                 LDI     0
00C6CB  FA01              :                 CAD     1(R1)
00C6CD  CA01              :                 ST      1(R1)
00C6CF  3F                :                 XPPC    R2              ; And continue
                            
                            ; UMAX ( x1 x2 -- x3 )
                            ;
                            ; x3 is the greater of x1 and x2.
                            
                                            WORD    "UMAX",NORMAL
        0000C6D0          = THIS            .SET    $
00C6D0  B0C6              +                 .WORD   LAST
00C6D2  00                +                 .BYTE   NORMAL
00C6D3  04                +                 .BYTE   STRLEN("UMAX")
00C6D4  554D4158          +                 .BYTE   "UMAX"
        0000C6D0          = LAST            .SET    THIS
                            UMAX:           FORTH
00C6D8  6ED0              +                 .WORD   DO_COLON-1
00C6DA  E9C2              :                 .WORD   TWO_DUP
00C6DC  0FCA              :                 .WORD   U_LESS
00C6DE  10D2E4C6          :                 .WORD   QUERY_BRANCH,.SKIP
00C6E2  E4C3              :                 .WORD   SWAP
00C6E4  4FC3              : .SKIP           .WORD   DROP
00C6E6  86CB              :                 .WORD   EXIT
                            
                            ; UMIN ( x1 x2 -- x3 )
                            ;
                            ; x3 is the lesser of x1 and x2.
                            
                                            WORD    "UMIN",NORMAL
        0000C6E8          = THIS            .SET    $
00C6E8  D0C6              +                 .WORD   LAST
00C6EA  00                +                 .BYTE   NORMAL
00C6EB  04                +                 .BYTE   STRLEN("UMIN")
00C6EC  554D494E          +                 .BYTE   "UMIN"
        0000C6E8          = LAST            .SET    THIS
                            UMIN:           FORTH
00C6F0  6ED0              +                 .WORD   DO_COLON-1
00C6F2  E9C2              :                 .WORD   TWO_DUP
00C6F4  0FCA              :                 .WORD   U_LESS
00C6F6  4FCA              :                 .WORD   INVERT

Portable National Semiconductor SC/MP Assembler [16.09]

00C6F8  10D2FEC6          :                 .WORD   QUERY_BRANCH,.SKIP
00C6FC  E4C3              :                 .WORD   SWAP
00C6FE  4FC3              : .SKIP           .WORD   DROP
00C700  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; Double Precision Arithmetic
                            ;-------------------------------------------------------------------------------
                            
                            ; ?DNEGATE ( d1 sign -- d1/-d1 )
                            ;
                            ; If sign is less than zero than negate d1 otherwise leave it unchanged.
                            
                            QUERY_DNEGATE:  FORTH
00C702  6ED0              +                 .WORD   DO_COLON-1
00C704  6BC9              :                 .WORD   ZERO_LESS
00C706  10D20CC7          :                 .WORD   QUERY_BRANCH,.SKIP
00C70A  7AC8              :                 .WORD   DNEGATE
00C70C  86CB              : .SKIP           .WORD   EXIT
                            
                            ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
                            ;
                            ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
                            
                                            WORD    "D+",NORMAL
        0000C70E          = THIS            .SET    $
00C70E  E8C6              +                 .WORD   LAST
00C710  00                +                 .BYTE   NORMAL
00C711  02                +                 .BYTE   STRLEN("D+")
00C712  442B              +                 .BYTE   "D+"
        0000C70E          = LAST            .SET    THIS
                            D_PLUS:         NATIVE
00C714  15C7              +                 .WORD   $+1
00C716  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C718  32                :                 XPAL    R1
00C719  C107              :                 LD      SP+1(MA)
00C71B  36                :                 XPAH    R1
00C71C  02                :                 CCL                     ; Add top cells
00C71D  C206              :                 LD      6(R1)
00C71F  F202              :                 ADD     2(R1)
00C721  CA06              :                 ST      6(R1)
00C723  C207              :                 LD      7(R1)
00C725  F203              :                 ADD     3(R1)
00C727  CA07              :                 ST      7(R1)
00C729  C204              :                 LD      4(R1)
00C72B  F200              :                 ADD     0(R1)
00C72D  CA04              :                 ST      4(R1)
00C72F  C205              :                 LD      5(R1)
00C731  F201              :                 ADD     1(R1)
00C733  CA05              :                 ST      5(R1)
00C735  A906              :                 ILD     SP+0(MA)        ; Drop the top two cells
00C737  A906              :                 ILD     SP+0(MA)
00C739  A906              :                 ILD     SP+0(MA)
00C73B  A906              :                 ILD     SP+0(MA)

Portable National Semiconductor SC/MP Assembler [16.09]

00C73D  3F                :                 XPPC    R2
                            
                            ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
                            ;
                            ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
                            
                                            WORD    "D-",NORMAL
        0000C73E          = THIS            .SET    $
00C73E  0EC7              +                 .WORD   LAST
00C740  00                +                 .BYTE   NORMAL
00C741  02                +                 .BYTE   STRLEN("D-")
00C742  442D              +                 .BYTE   "D-"
        0000C73E          = LAST            .SET    THIS
                            D_MINUS:        NATIVE
00C744  45C7              +                 .WORD   $+1
00C746  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C748  32                :                 XPAL    R1
00C749  C107              :                 LD      SP+1(MA)
00C74B  36                :                 XPAH    R1
00C74C  03                :                 SCL                     ; Subtract top cells
00C74D  C206              :                 LD      6(R1)
00C74F  FA02              :                 CAD     2(R1)
00C751  CA06              :                 ST      6(R1)
00C753  C207              :                 LD      7(R1)
00C755  FA03              :                 CAD     3(R1)
00C757  CA07              :                 ST      7(R1)
00C759  C204              :                 LD      4(R1)
00C75B  FA00              :                 CAD     0(R1)
00C75D  CA04              :                 ST      4(R1)
00C75F  C205              :                 LD      5(R1)
00C761  FA01              :                 CAD     1(R1)
00C763  CA05              :                 ST      5(R1)
00C765  A906              :                 ILD     SP+0(MA)        ; Drop the top two cells
00C767  A906              :                 ILD     SP+0(MA)
00C769  A906              :                 ILD     SP+0(MA)
00C76B  A906              :                 ILD     SP+0(MA)
00C76D  3F                :                 XPPC    R2
                            
                            ; D0< ( d -- flag )
                            ;
                            ; flag is true if and only if d is less than zero.
                            
                                            WORD    "D0<",NORMAL
        0000C76E          = THIS            .SET    $
00C76E  3EC7              +                 .WORD   LAST
00C770  00                +                 .BYTE   NORMAL
00C771  03                +                 .BYTE   STRLEN("D0<")
00C772  44303C            +                 .BYTE   "D0<"
        0000C76E          = LAST            .SET    THIS
                            D_ZERO_LESS:    NATIVE
00C775  76C7              +                 .WORD   $+1
00C777  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C779  32                :                 XPAL    R1
00C77A  C107              :                 LD      SP+1(MA)

Portable National Semiconductor SC/MP Assembler [16.09]

00C77C  36                :                 XPAH    R1
00C77D  02                :                 CCL                     ; Extract the sign bit
00C77E  C201              :                 LD      1(R1)
00C780  F201              :                 ADD     1(R1)
00C782  C400              :                 LDI     0               ; Work out sign byte
00C784  F4FF              :                 ADI     X'FF
00C786  E4FF              :                 XRI     X'FF
00C788  CA02              :                 ST      2(R1)           ; And create flag
00C78A  CA03              :                 ST      3(R1)
00C78C  A906              :                 ILD     SP+0(MA)        ; Drop top cell
00C78E  A906              :                 ILD     SP+0(MA)
00C790  3F                :                 XPPC    R2              ; And continue
                            
                            ; D0= ( d -- flag )
                            ;
                            ; flag is true if and only if d is equal to zero.
                            
                                            WORD    "D0=",NORMAL
        0000C791          = THIS            .SET    $
00C791  6EC7              +                 .WORD   LAST
00C793  00                +                 .BYTE   NORMAL
00C794  03                +                 .BYTE   STRLEN("D0=")
00C795  44303D            +                 .BYTE   "D0="
        0000C791          = LAST            .SET    THIS
                            D_ZERO_EQUAL:   NATIVE
00C798  99C7              +                 .WORD   $+1
00C79A  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C79C  32                :                 XPAL    R1
00C79D  C107              :                 LD      SP+1(MA)
00C79F  36                :                 XPAH    R1
00C7A0  C200              :                 LD      0(R1)           ; Test all the bits
00C7A2  DA01              :                 OR      1(R1)
00C7A4  DA02              :                 OR      2(R1)
00C7A6  DA03              :                 OR      3(R1)
00C7A8  9802              :                 JZ      .ZERO           ; Make the flag byte
00C7AA  C4FF              :                 LDI     X'FF
00C7AC  E4FF              : .ZERO           XRI     X'FF
00C7AE  CA02              :                 ST      2(R1)
00C7B0  CA03              :                 ST      3(R1)
00C7B2  A906              :                 ILD     SP+0(MA)        ; Drop top cell
00C7B4  A906              :                 ILD     SP+0(MA)
00C7B6  3F                :                 XPPC    R2              ; And continue
                            
                            ; D2* ( xd1 -- xd2 )
                            ;
                            ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
                            ; filling the vacated least-significant bit with zero.
                            
                                            WORD    "D2*",NORMAL
        0000C7B7          = THIS            .SET    $
00C7B7  91C7              +                 .WORD   LAST
00C7B9  00                +                 .BYTE   NORMAL
00C7BA  03                +                 .BYTE   STRLEN("D2*")
00C7BB  44322A            +                 .BYTE   "D2*"

Portable National Semiconductor SC/MP Assembler [16.09]

        0000C7B7          = LAST            .SET    THIS
                            D_TWO_STAR:     NATIVE
00C7BE  BFC7              +                 .WORD   $+1
00C7C0  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C7C2  32                :                 XPAL    R1
00C7C3  C107              :                 LD      SP+1(MA)
00C7C5  36                :                 XPAH    R1
00C7C6  02                :                 CCL                     ; Add top cells to themselves
00C7C7  C202              :                 LD      2(R1)
00C7C9  F202              :                 ADD     2(R1)
00C7CB  CA02              :                 ST      2(R1)
00C7CD  C203              :                 LD      3(R1)
00C7CF  F203              :                 ADD     3(R1)
00C7D1  CA03              :                 ST      3(R1)
00C7D3  C200              :                 LD      0(R1)
00C7D5  F200              :                 ADD     0(R1)
00C7D7  CA00              :                 ST      0(R1)
00C7D9  C201              :                 LD      1(R1)
00C7DB  F201              :                 ADD     1(R1)
00C7DD  CA01              :                 ST      1(R1)
00C7DF  3F                :                 XPPC    R2              ; And continue
                            
                            ; D2/ ( xd1 -- xd2 )
                            ;
                            ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
                            ; leaving the most-significant bit unchanged.
                            
                                            WORD    "D2/",NORMAL
        0000C7E0          = THIS            .SET    $
00C7E0  B7C7              +                 .WORD   LAST
00C7E2  00                +                 .BYTE   NORMAL
00C7E3  03                +                 .BYTE   STRLEN("D2/")
00C7E4  44322F            +                 .BYTE   "D2/"
        0000C7E0          = LAST            .SET    THIS
                            D_TWO_SLASH:
00C7E7  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C7E9  32                :                 XPAL    R1
00C7EA  C107              :                 LD      SP+1(MA)
00C7EC  36                :                 XPAH    R1
00C7ED  02                :                 CCL                     ; Extract the sign bit
00C7EE  C201              :                 LD      1(R1)
00C7F0  F201              :                 ADD     1(R1)
00C7F2  C201              :                 LD      1(R1)           ; Shift the value right
00C7F4  1F                :                 RRL
00C7F5  CA01              :                 ST      1(R1)
00C7F7  C200              :                 LD      0(R1)
00C7F9  1F                :                 RRL
00C7FA  CA00              :                 ST      0(R1)
00C7FC  C203              :                 LD      3(R1)
00C7FE  1F                :                 RRL
00C7FF  CA03              :                 ST      3(R1)
00C801  C202              :                 LD      2(R1)
00C803  1F                :                 RRL
00C804  CA02              :                 ST      2(R1)

Portable National Semiconductor SC/MP Assembler [16.09]

00C806  3F                :                 XPPC    R2              ; And continue
                            
                            ; D< ( d1 d2 -- flag )
                            ;
                            ; flag is true if and only if d1 is less than d2.
                            
                                            WORD    "D<",NORMAL
        0000C807          = THIS            .SET    $
00C807  E0C7              +                 .WORD   LAST
00C809  00                +                 .BYTE   NORMAL
00C80A  02                +                 .BYTE   STRLEN("D<")
00C80B  443C              +                 .BYTE   "D<"
        0000C807          = LAST            .SET    THIS
                            D_LESS:         FORTH
00C80D  6ED0              +                 .WORD   DO_COLON-1
00C80F  44C7              :                 .WORD   D_MINUS
00C811  75C7              :                 .WORD   D_ZERO_LESS
00C813  86CB              :                 .WORD   EXIT
                            
                            ; D= ( d1 d2 -- flag )
                            ;
                            ; flag is true if and only if d1 is bit-for-bit the same as d2.
                            
                                            WORD    "D=",NORMAL
        0000C815          = THIS            .SET    $
00C815  07C8              +                 .WORD   LAST
00C817  00                +                 .BYTE   NORMAL
00C818  02                +                 .BYTE   STRLEN("D=")
00C819  443D              +                 .BYTE   "D="
        0000C815          = LAST            .SET    THIS
                            D_EQUAL:        FORTH
00C81B  6ED0              +                 .WORD   DO_COLON-1
00C81D  44C7              :                 .WORD   D_MINUS
00C81F  98C7              :                 .WORD   D_ZERO_EQUAL
00C821  86CB              :                 .WORD   EXIT
                            
                            ; DABS ( d -- ud )
                            ;
                            ; ud is the absolute value of d.
                            
                                            WORD    "DABS",NORMAL
        0000C823          = THIS            .SET    $
00C823  15C8              +                 .WORD   LAST
00C825  00                +                 .BYTE   NORMAL
00C826  04                +                 .BYTE   STRLEN("DABS")
00C827  44414253          +                 .BYTE   "DABS"
        0000C823          = LAST            .SET    THIS
                            DABS:           FORTH
00C82B  6ED0              +                 .WORD   DO_COLON-1
00C82D  E9C2              :                 .WORD   TWO_DUP
00C82F  75C7              :                 .WORD   D_ZERO_LESS
00C831  10D237C8          :                 .WORD   QUERY_BRANCH,.SKIP
00C835  7AC8              :                 .WORD   DNEGATE
00C837  86CB              : .SKIP           .WORD   EXIT

Portable National Semiconductor SC/MP Assembler [16.09]

                            
                            ; DMAX ( d1 d2 -- d3 )
                            ;
                            ; d3 is the greater of d1 and d2.
                            
                                            WORD    "DMAX",NORMAL
        0000C839          = THIS            .SET    $
00C839  23C8              +                 .WORD   LAST
00C83B  00                +                 .BYTE   NORMAL
00C83C  04                +                 .BYTE   STRLEN("DMAX")
00C83D  444D4158          +                 .BYTE   "DMAX"
        0000C839          = LAST            .SET    THIS
                            DMAX:           FORTH
00C841  6ED0              +                 .WORD   DO_COLON-1
00C843  FAC2              :                 .WORD   TWO_OVER
00C845  FAC2              :                 .WORD   TWO_OVER
00C847  0DC8              :                 .WORD   D_LESS
00C849  10D24FC8          :                 .WORD   QUERY_BRANCH,.SKIP
00C84D  13C3              :                 .WORD   TWO_SWAP
00C84F  D6C2              : .SKIP           .WORD   TWO_DROP
00C851  86CB              :                 .WORD   EXIT
                            
                            ; DMIN ( d1 d2 -- d3 )
                            ;
                            ; d3 is the lesser of d1 and d2.
                            
                                            WORD    "DMIN",NORMAL
        0000C853          = THIS            .SET    $
00C853  39C8              +                 .WORD   LAST
00C855  00                +                 .BYTE   NORMAL
00C856  04                +                 .BYTE   STRLEN("DMIN")
00C857  444D494E          +                 .BYTE   "DMIN"
        0000C853          = LAST            .SET    THIS
                            DMIN:           FORTH
00C85B  6ED0              +                 .WORD   DO_COLON-1
00C85D  FAC2              :                 .WORD   TWO_OVER
00C85F  FAC2              :                 .WORD   TWO_OVER
00C861  0DC8              :                 .WORD   D_LESS
00C863  4FCA              :                 .WORD   INVERT
00C865  10D26BC8          :                 .WORD   QUERY_BRANCH,.SKIP
00C869  13C3              :                 .WORD   TWO_SWAP
00C86B  D6C2              : .SKIP           .WORD   TWO_DROP
00C86D  86CB              :                 .WORD   EXIT
                            
                            ; DNEGATE ( d1 -- d2 )
                            ;
                            ; d2 is the negation of d1.
                            
                                            WORD    "DNEGATE",NORMAL
        0000C86F          = THIS            .SET    $
00C86F  53C8              +                 .WORD   LAST
00C871  00                +                 .BYTE   NORMAL
00C872  07                +                 .BYTE   STRLEN("DNEGATE")
00C873  444E4547415445    +                 .BYTE   "DNEGATE"

Portable National Semiconductor SC/MP Assembler [16.09]

        0000C86F          = LAST            .SET    THIS
                            DNEGATE:        NATIVE
00C87A  7BC8              +                 .WORD   $+1
00C87C  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C87E  32                :                 XPAL    R1
00C87F  C107              :                 LD      SP+1(MA)
00C881  36                :                 XPAH    R1
00C882  03                :                 SCL                     ; Negate the top word
00C883  C400              :                 LDI     0
00C885  FA02              :                 CAD     2(R1)
00C887  CA02              :                 ST      2(R1)
00C889  C400              :                 LDI     0
00C88B  FA03              :                 CAD     3(R1)
00C88D  CA03              :                 ST      3(R1)
00C88F  C400              :                 LDI     0
00C891  FA00              :                 CAD     0(R1)
00C893  CA00              :                 ST      0(R1)
00C895  C400              :                 LDI     0
00C897  FA01              :                 CAD     1(R1)
00C899  CA01              :                 ST      1(R1)
00C89B  3F                :                 XPPC    R2              ; And continue
                            
                            ;===============================================================================
                            ; Mixed Arithmetic
                            ;-------------------------------------------------------------------------------
                            
                            ; D>S ( d -- n )
                            ;
                            ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
                            ; range of a signed single-cell number.
                            
                                            WORD    "D>S",NORMAL
        0000C89C          = THIS            .SET    $
00C89C  6FC8              +                 .WORD   LAST
00C89E  00                +                 .BYTE   NORMAL
00C89F  03                +                 .BYTE   STRLEN("D>S")
00C8A0  443E53            +                 .BYTE   "D>S"
        0000C89C          = LAST            .SET    THIS
                            D_TO_S:         NATIVE
00C8A3  A4C8              +                 .WORD   $+1
00C8A5  A906              :                 ILD     SP+0(MA)        ; Drop the high word
00C8A7  A906              :                 ILD     SP+0(MA)
00C8A9  3F                :                 XPPC    R2              ; And continue
                            
                            ; M* ( n1 n2 -- d )
                            ;
                            ; d is the signed product of n1 times n2.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   2DUP XOR >R                 carries sign of the result
                            ;   SWAP ABS SWAP ABS UM*
                            ;   R> ?DNEGATE
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                                            WORD    "M*",NORMAL
        0000C8AA          = THIS            .SET    $
00C8AA  9CC8              +                 .WORD   LAST
00C8AC  00                +                 .BYTE   NORMAL
00C8AD  02                +                 .BYTE   STRLEN("M*")
00C8AE  4D2A              +                 .BYTE   "M*"
        0000C8AA          = LAST            .SET    THIS
                            M_STAR:         FORTH
00C8B0  6ED0              +                 .WORD   DO_COLON-1
00C8B2  E9C2              :                 .WORD   TWO_DUP
00C8B4  E3CA              :                 .WORD   XOR
00C8B6  52C4              :                 .WORD   TO_R
00C8B8  E4C3              :                 .WORD   SWAP
00C8BA  17C6              :                 .WORD   ABS
00C8BC  E4C3              :                 .WORD   SWAP
00C8BE  17C6              :                 .WORD   ABS
00C8C0  55C9              :                 .WORD   UM_STAR
00C8C2  C3C4              :                 .WORD   R_FROM
00C8C4  02C7              :                 .WORD   QUERY_DNEGATE
00C8C6  86CB              :                 .WORD   EXIT
                            
                            ; M*/ ( d1 n1 +n2 -- d2 )
                            ;
                            ; Multiply d1 by n1 producing the triple-cell intermediate result t. Divide t
                            ; by +n2 giving the double-cell quotient d2. An ambiguous condition exists if
                            ; +n2 is zero or negative, or the quotient lies outside of the range of a
                            ; double-precision signed integer.
                            
                            
                            
                            ; M+ ( d1|ud1 n -- d2|ud2 )
                            ;
                            ; Add n to d1|ud1, giving the sum d2|ud2.
                            
                                            WORD    "M+",NORMAL
        0000C8C8          = THIS            .SET    $
00C8C8  AAC8              +                 .WORD   LAST
00C8CA  00                +                 .BYTE   NORMAL
00C8CB  02                +                 .BYTE   STRLEN("M+")
00C8CC  4D2B              +                 .BYTE   "M+"
        0000C8C8          = LAST            .SET    THIS
                            M_PLUS:         NATIVE
00C8CE  CFC8              +                 .WORD   $+1
00C8D0  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C8D2  32                :                 XPAL    R1
00C8D3  C107              :                 LD      SP+1(MA)
00C8D5  36                :                 XPAH    R1
00C8D6  02                :                 CCL                     ; Add n to d
00C8D7  C204              :                 LD      4(R1)
00C8D9  F200              :                 ADD     0(R1)
00C8DB  CA04              :                 ST      4(R1)
00C8DD  C205              :                 LD      5(R1)
00C8DF  F201              :                 ADD     1(R1)
00C8E1  CA05              :                 ST      5(R1)

Portable National Semiconductor SC/MP Assembler [16.09]

00C8E3  C202              :                 LD      2(R1)
00C8E5  F400              :                 ADI     0
00C8E7  CA02              :                 ST      2(R1)
00C8E9  C203              :                 LD      3(R1)
00C8EB  F400              :                 ADI     0
00C8ED  CA03              :                 ST      3(R1)
00C8EF  A906              :                 ILD     SP+0(MA)        ; Drop the top cell
00C8F1  A906              :                 ILD     SP+0(MA)
00C8F3  3F                :                 XPPC    R2              ; And continue
                            
                            ; S>D ( n -- d )
                            ;
                            ; Convert the number n to the double-cell number d with the same numerical
                            ; value.
                            
                                            WORD    "S>D",NORMAL
        0000C8F4          = THIS            .SET    $
00C8F4  C8C8              +                 .WORD   LAST
00C8F6  00                +                 .BYTE   NORMAL
00C8F7  03                +                 .BYTE   STRLEN("S>D")
00C8F8  533E44            +                 .BYTE   "S>D"
        0000C8F4          = LAST            .SET    THIS
                            S_TO_D:         FORTH
00C8FB  6ED0              +                 .WORD   DO_COLON-1
00C8FD  5DC3              :                 .WORD   DUP
00C8FF  6BC9              :                 .WORD   ZERO_LESS
00C901  86CB              :                 .WORD   EXIT
                            
                            ; SM/REM ( d1 n1 -- n2 n3 )
                            ;
                            ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
                            ; Input and output stack arguments are signed. An ambiguous condition exists if
                            ; n1 is zero or if the quotient lies outside the range of a single-cell signed
                            ; integer.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   2DUP XOR >R                 sign of quotient
                            ;   OVER >R                     sign of remainder
                            ;   ABS >R DABS R> UM/MOD
                            ;   SWAP R> ?NEGATE
                            ;   SWAP R> ?NEGATE ;
                            
                                            WORD    "SM/REM",NORMAL
        0000C903          = THIS            .SET    $
00C903  F4C8              +                 .WORD   LAST
00C905  00                +                 .BYTE   NORMAL
00C906  06                +                 .BYTE   STRLEN("SM/REM")
00C907  534D2F52454D      +                 .BYTE   "SM/REM"
        0000C903          = LAST            .SET    THIS
                            SM_SLASH_REM:   FORTH
00C90D  6ED0              +                 .WORD   DO_COLON-1
00C90F  E9C2              :                 .WORD   TWO_DUP
00C911  E3CA              :                 .WORD   XOR

Portable National Semiconductor SC/MP Assembler [16.09]

00C913  52C4              :                 .WORD   TO_R
00C915  87C3              :                 .WORD   OVER
00C917  52C4              :                 .WORD   TO_R
00C919  17C6              :                 .WORD   ABS
00C91B  52C4              :                 .WORD   TO_R
00C91D  2BC8              :                 .WORD   DABS
00C91F  C3C4              :                 .WORD   R_FROM
00C921  62C9              :                 .WORD   UM_SLASH_MOD
00C923  E4C3              :                 .WORD   SWAP
00C925  C3C4              :                 .WORD   R_FROM
00C927  04C6              :                 .WORD   QUERY_NEGATE
00C929  E4C3              :                 .WORD   SWAP
00C92B  C3C4              :                 .WORD   R_FROM
00C92D  04C6              :                 .WORD   QUERY_NEGATE
00C92F  86CB              :                 .WORD   EXIT
                            
                            ; UD* ( ud1 d2 -- ud3)
                            ;
                            ; 32*16->32 multiply
                            ;
                            ;   DUP >R UM* DROP SWAP R> UM* ROT + ;
                            
                                            WORD    "UD*",NORMAL
        0000C931          = THIS            .SET    $
00C931  03C9              +                 .WORD   LAST
00C933  00                +                 .BYTE   NORMAL
00C934  03                +                 .BYTE   STRLEN("UD*")
00C935  55442A            +                 .BYTE   "UD*"
        0000C931          = LAST            .SET    THIS
                            UD_STAR:        FORTH
00C938  6ED0              +                 .WORD   DO_COLON-1
00C93A  5DC3              :                 .WORD   DUP
00C93C  52C4              :                 .WORD   TO_R
00C93E  55C9              :                 .WORD   UM_STAR
00C940  4FC3              :                 .WORD   DROP
00C942  E4C3              :                 .WORD   SWAP
00C944  C3C4              :                 .WORD   R_FROM
00C946  55C9              :                 .WORD   UM_STAR
00C948  B7C3              :                 .WORD   ROT
00C94A  48C5              :                 .WORD   PLUS
00C94C  86CB              :                 .WORD   EXIT
                            
                            ; UM* ( u1 u2 -- ud )
                            ;
                            ; Multiply u1 by u2, giving the unsigned double-cell product ud. All values and
                            ; arithmetic are unsigned.
                            
                                            WORD    "UM*",NORMAL
        0000C94E          = THIS            .SET    $
00C94E  31C9              +                 .WORD   LAST
00C950  00                +                 .BYTE   NORMAL
00C951  03                +                 .BYTE   STRLEN("UM*")
00C952  554D2A            +                 .BYTE   "UM*"
        0000C94E          = LAST            .SET    THIS

Portable National Semiconductor SC/MP Assembler [16.09]

                            UM_STAR:        NATIVE
00C955  56C9              +                 .WORD   $+1
                                    .IF     0
                            ;                lda     <1                      ; Fetch multiplier
                            ;                pha
                            ;                stz     <1                      ; Clear the result
                            ;                ldx     #16
                            ;UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
                            ;                lsr     a
                            ;                bcc     UM_STAR_2               ; Not set, no add
                            ;                lda     1,s                     ; Fetch multiplicand
                            ;                clc
                            ;                adc     <1
                            ;                sta     <1
                            ;UM_STAR_2:      ror     <1                      ; Rotate high word down
                            ;                ror     <3
                            ;                dex
                            ;                bne     UM_STAR_1
                            ;                pla
                                    .ENDIF
00C957  3F                :                 XPPC    R2              ; And continue
                            
                            ; UM/MOD ( ud u1 -- u2 u3 )
                            ;
                            ; Divide ud by u1, giving the quotient u3 and the remainder u2. All values and
                            ; arithmetic are unsigned. An ambiguous condition exists if u1 is zero or if the
                            ; quotient lies outside the range of a single-cell unsigned integer.
                            
                                            WORD    "UM/MOD",NORMAL
        0000C958          = THIS            .SET    $
00C958  4EC9              +                 .WORD   LAST
00C95A  00                +                 .BYTE   NORMAL
00C95B  06                +                 .BYTE   STRLEN("UM/MOD")
00C95C  554D2F4D4F44      +                 .BYTE   "UM/MOD"
        0000C958          = LAST            .SET    THIS
                            UM_SLASH_MOD:   NATIVE
00C962  63C9              +                 .WORD   $+1
                                    .IF     0
                            ;                sec                             ; Check for overflow
                            ;                lda     <3
                            ;                sbc     <1
                            ;                bcs     UM_SLASH_MOD_3
                            
                            ;                ldx     #17
                            ;UM_SLASH_MOD_1: rol     <5                      ; Rotate dividend lo
                            ;                dex
                            ;                beq     UM_SLASH_MOD_4
                            ;                rol     <3
                            ;                bcs     UM_SLASH_MOD_2          ; Carry set dividend > divisor
                            
                            ;                lda     <3                      ; Is dividend < divisor?;
                            ;                cmp     <1
                            ;                bcc     UM_SLASH_MOD_1          ; Yes, shift in 0
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                            ;UM_SLASH_MOD_2: lda     <3                      ; Reduce dividend
                            ;                sbc     <1
                            ;                sta     <3
                            ;                bra     UM_SLASH_MOD_1          ; Shift in 1
                            
                            ;UM_SLASH_MOD_3: lda     #$ffff                  ; Overflowed set results
                            ;                sta     <3
                            ;                sta     <5
                            ;UM_SLASH_MOD_4: tdc                             ; Drop top word
                            ;                inc     a
                            ;                inc     a
                            ;                tcd
                            ;                jmp     SWAP                    ; Swap quotient and remainder
                                    .ENDIF
00C964  3F                :                 XPPC    R2              ; And continue
                            
                            ;===============================================================================
                            ; Comparisons
                            ;-------------------------------------------------------------------------------
                            
                            ; 0< ( n -- flag )
                            ;
                            ; flag is true if and only if n is less than zero.
                            
                                            WORD    "0<",NORMAL
        0000C965          = THIS            .SET    $
00C965  58C9              +                 .WORD   LAST
00C967  00                +                 .BYTE   NORMAL
00C968  02                +                 .BYTE   STRLEN("0<")
00C969  303C              +                 .BYTE   "0<"
        0000C965          = LAST            .SET    THIS
                            ZERO_LESS:      NATIVE
00C96B  6CC9              +                 .WORD   $+1
00C96D  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C96F  32                :                 XPAL    R1
00C970  C107              :                 LD      SP+1(MA)
00C972  36                :                 XPAH    R1
00C973  02                :                 CCL                     ; Extract the sign bit
00C974  C201              :                 LD      1(R1)
00C976  F201              :                 ADD     1(R1)
00C978  C400              :                 LDI     0               ; Convert to flag value
00C97A  F4FF              :                 ADI     X'FF
00C97C  E4FF              :                 XRI     X'FF
00C97E  CA00              :                 ST      0(R1)           ; And write back to the stack
00C980  CA01              :                 ST      1(R1)
00C982  3F                :                 XPPC    R2              ; And continue
                            
                            ; 0<> ( x -- flag )
                            ;
                            ; flag is true if and only if x is not equal to zero.
                            
                                            WORD    "0<>",NORMAL
        0000C983          = THIS            .SET    $
00C983  65C9              +                 .WORD   LAST

Portable National Semiconductor SC/MP Assembler [16.09]

00C985  00                +                 .BYTE   NORMAL
00C986  03                +                 .BYTE   STRLEN("0<>")
00C987  303C3E            +                 .BYTE   "0<>"
        0000C983          = LAST            .SET    THIS
                            ZERO_NOT_EQUAL: NATIVE
00C98A  8BC9              +                 .WORD   $+1
00C98C  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C98E  32                :                 XPAL    R1
00C98F  C107              :                 LD      SP+1(MA)
00C991  36                :                 XPAH    R1
00C992  C200              :                 LD      0(R1)           ; Test bits in top cell
00C994  DA01              :                 OR      1(R1)
00C996  9802              :                 JZ      .ZERO           ; And form the flag
00C998  C4FF              :                 LDI     X'FF
00C99A  CA00              : .ZERO           ST      0(R1)           ; Write back
00C99C  CA01              :                 ST      1(R1)
00C99E  3F                :                 XPPC    R2              ; And continue
                            
                            
                            ; 0= ( x -- flag )
                            ;
                            ; flag is true if and only if x is equal to zero.
                            
                                            WORD    "0=",NORMAL
        0000C99F          = THIS            .SET    $
00C99F  83C9              +                 .WORD   LAST
00C9A1  00                +                 .BYTE   NORMAL
00C9A2  02                +                 .BYTE   STRLEN("0=")
00C9A3  303D              +                 .BYTE   "0="
        0000C99F          = LAST            .SET    THIS
                            ZERO_EQUAL:     NATIVE
00C9A5  A6C9              +                 .WORD   $+1
00C9A7  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00C9A9  32                :                 XPAL    R1
00C9AA  C107              :                 LD      SP+1(MA)
00C9AC  36                :                 XPAH    R1
00C9AD  C200              :                 LD      0(R1)           ; Test bits in top cell
00C9AF  DA01              :                 OR      1(R1)
00C9B1  9802              :                 JZ      .ZERO           ; And form the flag
00C9B3  C4FF              :                 LDI     X'FF
00C9B5  E4FF              : .ZERO           XRI     X'FF
00C9B7  CA00              :                 ST      0(R1)           ; Write back
00C9B9  CA01              :                 ST      1(R1)
00C9BB  3F                :                 XPPC    R2              ; And continue
                            
                            ; 0> ( n -- flag )
                            ;
                            ; flag is true if and only if n is greater than zero.
                            
                                            WORD    "0>",NORMAL
        0000C9BC          = THIS            .SET    $
00C9BC  9FC9              +                 .WORD   LAST
00C9BE  00                +                 .BYTE   NORMAL
00C9BF  02                +                 .BYTE   STRLEN("0>")

Portable National Semiconductor SC/MP Assembler [16.09]

00C9C0  303E              +                 .BYTE   "0>"
        0000C9BC          = LAST            .SET    THIS
                            ZERO_GREATER:   FORTH
00C9C2  6ED0              +                 .WORD   DO_COLON-1
00C9C4  5DC3              :                 .WORD   DUP
00C9C6  A5C9              :                 .WORD   ZERO_EQUAL
00C9C8  E4C3              :                 .WORD   SWAP
00C9CA  6BC9              :                 .WORD   ZERO_LESS
00C9CC  91CA              :                 .WORD   OR
00C9CE  4FCA              :                 .WORD   INVERT
00C9D0  86CB              :                 .WORD   EXIT
                            
                            ; < ( n1 n2 -- flag )
                            ;
                            ; flag is true if and only if n1 is less than n2.
                            
                                            WORD    "<",NORMAL
        0000C9D2          = THIS            .SET    $
00C9D2  BCC9              +                 .WORD   LAST
00C9D4  00                +                 .BYTE   NORMAL
00C9D5  01                +                 .BYTE   STRLEN("<")
00C9D6  3C                +                 .BYTE   "<"
        0000C9D2          = LAST            .SET    THIS
                            LESS:           FORTH
00C9D7  6ED0              +                 .WORD   DO_COLON-1
00C9D9  E4C3              :                 .WORD   SWAP
00C9DB  01CA              :                 .WORD   GREATER
00C9DD  86CB              :                 .WORD   EXIT
                            
                            ; <> ( x1 x2 -- flag )
                            ;
                            ; flag is true if and only if x1 is not bit-for-bit the same as x2.
                            
                                            WORD    "<>",NORMAL
        0000C9DF          = THIS            .SET    $
00C9DF  D2C9              +                 .WORD   LAST
00C9E1  00                +                 .BYTE   NORMAL
00C9E2  02                +                 .BYTE   STRLEN("<>")
00C9E3  3C3E              +                 .BYTE   "<>"
        0000C9DF          = LAST            .SET    THIS
                            NOT_EQUAL:      FORTH
00C9E5  6ED0              +                 .WORD   DO_COLON-1
00C9E7  67C5              :                 .WORD   MINUS
00C9E9  A5C9              :                 .WORD   ZERO_EQUAL
00C9EB  4FCA              :                 .WORD   INVERT
00C9ED  86CB              :                 .WORD   EXIT
                            
                            ; = ( x1 x2 -- flag )
                            ;
                            ; flag is true if and only if x1 is bit-for-bit the same as x2.
                            
                                            WORD    "=",NORMAL
        0000C9EF          = THIS            .SET    $
00C9EF  DFC9              +                 .WORD   LAST

Portable National Semiconductor SC/MP Assembler [16.09]

00C9F1  00                +                 .BYTE   NORMAL
00C9F2  01                +                 .BYTE   STRLEN("=")
00C9F3  3D                +                 .BYTE   "="
        0000C9EF          = LAST            .SET    THIS
                            EQUAL:          FORTH
00C9F4  6ED0              +                 .WORD   DO_COLON-1
00C9F6  67C5              :                 .WORD   MINUS
00C9F8  A5C9              :                 .WORD   ZERO_EQUAL
00C9FA  86CB              :                 .WORD   EXIT
                            
                            ; > ( n1 n2 -- flag )
                            ;
                            ; flag is true if and only if n1 is greater than n2.
                            
                                            WORD    ">",NORMAL
        0000C9FC          = THIS            .SET    $
00C9FC  EFC9              +                 .WORD   LAST
00C9FE  00                +                 .BYTE   NORMAL
00C9FF  01                +                 .BYTE   STRLEN(">")
00CA00  3E                +                 .BYTE   ">"
        0000C9FC          = LAST            .SET    THIS
                            GREATER:        FORTH
00CA01  6ED0              +                 .WORD   DO_COLON-1
00CA03  67C5              :                 .WORD   MINUS
00CA05  C2C9              :                 .WORD   ZERO_GREATER
00CA07  86CB              :                 .WORD   EXIT
                            
                            ; U< ( u1 u2 -- flag )
                            ;
                            ; flag is true if and only if u1 is less than u2.
                            
                                            WORD    "U<",NORMAL
        0000CA09          = THIS            .SET    $
00CA09  FCC9              +                 .WORD   LAST
00CA0B  00                +                 .BYTE   NORMAL
00CA0C  02                +                 .BYTE   STRLEN("U<")
00CA0D  553C              +                 .BYTE   "U<"
        0000CA09          = LAST            .SET    THIS
                            U_LESS:         FORTH
00CA0F  6ED0              +                 .WORD   DO_COLON-1
00CA11  67C5              :                 .WORD   MINUS
00CA13  6BC9              :                 .WORD   ZERO_LESS
00CA15  86CB              :                 .WORD   EXIT
                            
                            ; U> ( u1 u2 -- flag )
                            ;
                            ; flag is true if and only if u1 is greater than u2.
                            
                                            WORD    "U>",NORMAL
        0000CA17          = THIS            .SET    $
00CA17  09CA              +                 .WORD   LAST
00CA19  00                +                 .BYTE   NORMAL
00CA1A  02                +                 .BYTE   STRLEN("U>")
00CA1B  553E              +                 .BYTE   "U>"

Portable National Semiconductor SC/MP Assembler [16.09]

        0000CA17          = LAST            .SET    THIS
                            U_GREATER:      FORTH
00CA1D  6ED0              +                 .WORD   DO_COLON-1
00CA1F  E4C3              :                 .WORD   SWAP
00CA21  0FCA              :                 .WORD   U_LESS
00CA23  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; Logical Operations
                            ;-------------------------------------------------------------------------------
                            
                            ; AND ( x1 x2 -- x3 )
                            ;
                            ; x3 is the bit-by-bit logical “and” of x1 with x2.
                            
                                            WORD    "AND",NORMAL
        0000CA25          = THIS            .SET    $
00CA25  17CA              +                 .WORD   LAST
00CA27  00                +                 .BYTE   NORMAL
00CA28  03                +                 .BYTE   STRLEN("AND")
00CA29  414E44            +                 .BYTE   "AND"
        0000CA25          = LAST            .SET    THIS
                            AND:            NATIVE
00CA2C  2DCA              +                 .WORD   $+1
00CA2E  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00CA30  32                :                 XPAL    R1
00CA31  C107              :                 LD      SP+1(MA)
00CA33  36                :                 XPAH    R1
00CA34  C202              :                 LD      2(R1)           ; Perform AND
00CA36  D200              :                 AND     0(R1)
00CA38  CA02              :                 ST      2(R1)
00CA3A  C203              :                 LD      3(R1)
00CA3C  D201              :                 AND     1(R1)
00CA3E  CA03              :                 ST      3(R1)
00CA40  A906              :                 ILD     SP+0(MA)        ; Drop top cell
00CA42  A906              :                 ILD     SP+0(MA)
00CA44  3F                :                 XPPC    R2              ; And continue
                            
                            ; INVERT ( x1 -- x2 )
                            ;
                            ; Invert all bits of x1, giving its logical inverse x2.
                            
                                            WORD    "INVERT",NORMAL
        0000CA45          = THIS            .SET    $
00CA45  25CA              +                 .WORD   LAST
00CA47  00                +                 .BYTE   NORMAL
00CA48  06                +                 .BYTE   STRLEN("INVERT")
00CA49  494E56455254      +                 .BYTE   "INVERT"
        0000CA45          = LAST            .SET    THIS
                            INVERT:         FORTH
00CA4F  6ED0              +                 .WORD   DO_COLON-1
00CA51  FFC0              :                 .WORD   TRUE
00CA53  E3CA              :                 .WORD   XOR
00CA55  86CB              :                 .WORD   EXIT

Portable National Semiconductor SC/MP Assembler [16.09]

                            
                            ; LSHIFT ( x1 u -- x2 )
                            ;
                            ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
                            ; into the least significant bits vacated by the shift. An ambiguous condition
                            ; exists if u is greater than or equal to the number of bits in a cell.
                            
                                            WORD    "LSHIFT",NORMAL
        0000CA57          = THIS            .SET    $
00CA57  45CA              +                 .WORD   LAST
00CA59  00                +                 .BYTE   NORMAL
00CA5A  06                +                 .BYTE   STRLEN("LSHIFT")
00CA5B  4C5348494654      +                 .BYTE   "LSHIFT"
        0000CA57          = LAST            .SET    THIS
                            LSHIFT:         NATIVE
00CA61  62CA              +                 .WORD   $+1
00CA63  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00CA65  32                :                 XPAL    R1
00CA66  C107              :                 LD      SP+1(MA)
00CA68  36                :                 XPAH    R1
00CA69  C200              : .LOOP           LD      0(R1)           ; Any shift left?
00CA6B  DA01              :                 OR      1(R1)
00CA6D  9817              :                 JZ      .DONE
00CA6F  02                :                 CCL                     ; Shift by one bit
00CA70  C202              :                 LD      2(R1)
00CA72  F202              :                 ADD     2(R1)
00CA74  CA02              :                 ST      2(R1)
00CA76  C203              :                 LD      3(R1)
00CA78  F203              :                 ADD     3(R1)
00CA7A  CA03              :                 ST      3(R1)
00CA7C  C200              :                 LD      0(R1)           ; Decrement bit count
00CA7E  9C02              :                 JNZ     .DECR
00CA80  BA01              :                 DLD     1(R1)
00CA82  BA00              : .DECR           DLD     0(R1)
00CA84  90E3              :                 JMP     .LOOP
00CA86  A906              : .DONE           ILD     SP+0(MA)        ; Drop the bit count
00CA88  A906              :                 ILD     SP+0(MA)
00CA8A  3F                :                 XPPC    R2              ; And continue
                            
                            ; OR ( x1 x2 -- x3 )
                            ;
                            ; x3 is the bit-by-bit inclusive-or of x1 with x2.
                            
                                            WORD    "OR",NORMAL
        0000CA8B          = THIS            .SET    $
00CA8B  57CA              +                 .WORD   LAST
00CA8D  00                +                 .BYTE   NORMAL
00CA8E  02                +                 .BYTE   STRLEN("OR")
00CA8F  4F52              +                 .BYTE   "OR"
        0000CA8B          = LAST            .SET    THIS
                            OR:             NATIVE
00CA91  92CA              +                 .WORD   $+1
00CA93  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00CA95  32                :                 XPAL    R1

Portable National Semiconductor SC/MP Assembler [16.09]

00CA96  C107              :                 LD      SP+1(MA)
00CA98  36                :                 XPAH    R1
00CA99  C202              :                 LD      2(R1)           ; Perform OR
00CA9B  DA00              :                 OR      0(R1)
00CA9D  CA02              :                 ST      2(R1)
00CA9F  C203              :                 LD      3(R1)
00CAA1  DA01              :                 OR      1(R1)
00CAA3  CA03              :                 ST      3(R1)
00CAA5  A906              :                 ILD     SP+0(MA)        ; Drop top cell
00CAA7  A906              :                 ILD     SP+0(MA)
00CAA9  3F                :                 XPPC    R2              ; And continue
                            
                            ; RSHIFT ( x1 u -- x2 )
                            ;
                            ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
                            ; into the most significant bits vacated by the shift. An ambiguous condition
                            ; exists if u is greater than or equal to the number of bits in a cell.
                            
                                            WORD    "RSHIFT",NORMAL
        0000CAAA          = THIS            .SET    $
00CAAA  8BCA              +                 .WORD   LAST
00CAAC  00                +                 .BYTE   NORMAL
00CAAD  06                +                 .BYTE   STRLEN("RSHIFT")
00CAAE  525348494654      +                 .BYTE   "RSHIFT"
        0000CAAA          = LAST            .SET    THIS
                            RSHIFT:         NATIVE
00CAB4  B5CA              +                 .WORD   $+1
00CAB6  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00CAB8  32                :                 XPAL    R1
00CAB9  C107              :                 LD      SP+1(MA)
00CABB  36                :                 XPAH    R1
00CABC  C200              : .LOOP           LD      0(R1)           ; Any shift left?
00CABE  DA01              :                 OR      1(R1)
00CAC0  9815              :                 JZ      .DONE
00CAC2  02                :                 CCL
00CAC3  C203              :                 LD      3(R1)           ; Shift by one bit
00CAC5  1F                :                 RRL
00CAC6  CA02              :                 ST      2(R1)
00CAC8  C203              :                 LD      3(R1)
00CACA  1F                :                 RRL
00CACB  CA03              :                 ST      3(R1)
00CACD  C200              :                 LD      0(R1)           ; Decrement bit count
00CACF  9C02              :                 JNZ     .DECR
00CAD1  BA01              :                 DLD     1(R1)
00CAD3  BA00              : .DECR           DLD     0(R1)
00CAD5  90E5              :                 JMP     .LOOP
00CAD7  A906              : .DONE           ILD     SP+0(MA)        ; Drop the bit count
00CAD9  A906              :                 ILD     SP+0(MA)
00CADB  3F                :                 XPPC    R2              ; And continue
                            
                            ; XOR ( x1 x2 -- x3 )
                            ;
                            ; x3 is the bit-by-bit exclusive-or of x1 with x2.
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                                            WORD    "XOR",NORMAL
        0000CADC          = THIS            .SET    $
00CADC  AACA              +                 .WORD   LAST
00CADE  00                +                 .BYTE   NORMAL
00CADF  03                +                 .BYTE   STRLEN("XOR")
00CAE0  584F52            +                 .BYTE   "XOR"
        0000CADC          = LAST            .SET    THIS
                            XOR:            NATIVE
00CAE3  E4CA              +                 .WORD   $+1
00CAE5  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00CAE7  32                :                 XPAL    R1
00CAE8  C107              :                 LD      SP+1(MA)
00CAEA  36                :                 XPAH    R1
00CAEB  C202              :                 LD      2(R1)           ; Perform AND
00CAED  E200              :                 XOR     0(R1)
00CAEF  CA02              :                 ST      2(R1)
00CAF1  C203              :                 LD      3(R1)
00CAF3  E201              :                 XOR     1(R1)
00CAF5  CA03              :                 ST      3(R1)
00CAF7  A906              :                 ILD     SP+0(MA)        ; Drop top cell
00CAF9  A906              :                 ILD     SP+0(MA)
00CAFB  3F                :                 XPPC    R2              ; And continue
                            
                            ;===============================================================================
                            ; Control Words
                            ;-------------------------------------------------------------------------------
                            
                            ; ?ABORT
                            ;
                            ;   ROT IF TYPE ABORT THEN 2DROP ;
                            
                            QUERY_ABORT:    FORTH
00CAFC  6ED0              +                 .WORD   DO_COLON-1
00CAFE  B7C3              :                 .WORD   ROT
00CB00  10D208CB          :                 .WORD   QUERY_BRANCH,.SKIP
00CB04  BCD4              :                 .WORD   TYPE
00CB06  15CB              :                 .WORD   ABORT
00CB08  D6C2              : .SKIP           .WORD   TWO_DROP
00CB0A  86CB              :                 .WORD   EXIT
                            
                            ; ABORT ( i*x -- ) ( R: j*x -- )
                            ;
                            ; Empty the data stack and perform the function of QUIT, which includes
                            ; emptying the return stack, without displaying a message.
                            
                                            WORD    "ABORT",NORMAL
        0000CB0C          = THIS            .SET    $
00CB0C  DCCA              +                 .WORD   LAST
00CB0E  00                +                 .BYTE   NORMAL
00CB0F  05                +                 .BYTE   STRLEN("ABORT")
00CB10  41424F5254        +                 .BYTE   "ABORT"
        0000CB0C          = LAST            .SET    THIS
                            ABORT:          FORTH
00CB15  6ED0              +                 .WORD   DO_COLON-1

Portable National Semiconductor SC/MP Assembler [16.09]

00CB17  1BCB              :                 .WORD   DO_ABORT
00CB19  A3CB              :                 .WORD   QUIT
                            
                            DO_ABORT:       NATIVE
00CB1B  1CCB              +                 .WORD   $+1
00CB1D  C480              :                 LDI     LO(DSTACK_END)  ; Reset the data stack pointer
00CB1F  C906              :                 ST      SP+0(MA)
00CB21  C410              :                 LDI     HI(DSTACK_END)
00CB23  C907              :                 ST      SP+1(MA)
00CB25  3F                :                 XPPC    R2              ; And continue
                            
                            ; (BUILD) ( dtc-addr -- )
                            ;
                            ; Adds a jump the to exection function for the new word.
                            
                            ;               WORD    "(BUILD)",NORMAL
                            BUILD:          FORTH
00CB26  6ED0              +                 .WORD   DO_COLON-1
00CB28  C0C5              :                 .WORD   ONE_MINUS
00CB2A  8CC1              :                 .WORD   COMMA
00CB2C  86CB              :                 .WORD   EXIT
                            
                            ; CREATE ( -- )
                            ;
                            ; Skip leading space delimiters. Parse name delimited by a space. Create a
                            ; definition for name with the execution semantics defined below. If the data-
                            ; space pointer is not aligned, reserve enough data space to align it. The new
                            ; data-space pointer defines name’s data field. CREATE does not allocate data
                            ; space in name’s data field.
                            
                                            WORD    "CREATE",NORMAL
        0000CB2E          = THIS            .SET    $
00CB2E  0CCB              +                 .WORD   LAST
00CB30  00                +                 .BYTE   NORMAL
00CB31  06                +                 .BYTE   STRLEN("CREATE")
00CB32  435245415445      +                 .BYTE   "CREATE"
        0000CB2E          = LAST            .SET    THIS
                            CREATE:         FORTH
00CB38  6ED0              +                 .WORD   DO_COLON-1
00CB3A  A8C0              :                 .WORD   LATEST
00CB3C  C9C1              :                 .WORD   FETCH
00CB3E  8CC1              :                 .WORD   COMMA
00CB40  DCC0              :                 .WORD   ZERO
00CB42  24C2              :                 .WORD   C_COMMA
00CB44  5FC2              :                 .WORD   HERE
00CB46  A8C0              :                 .WORD   LATEST
00CB48  32C1              :                 .WORD   STORE
00CB4A  E6C0              :                 .WORD   BL
00CB4C  02CF              :                 .WORD   WORD
00CB4E  3AC2              :                 .WORD   C_FETCH
00CB50  B0C5              :                 .WORD   ONE_PLUS
00CB52  EFC1              :                 .WORD   ALLOT
00CB54  86CB              :                 .WORD   EXIT
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; EXECUTE ( i*x xt -- j*x )
                            ;
                            ; Remove xt from the stack and perform the semantics identified by it. Other
                            ; stack effects are due to the word EXECUTEd.
                            
                                            WORD    "EXECUTE",NORMAL
        0000CB56          = THIS            .SET    $
00CB56  2ECB              +                 .WORD   LAST
00CB58  00                +                 .BYTE   NORMAL
00CB59  07                +                 .BYTE   STRLEN("EXECUTE")
00CB5A  45584543555445    +                 .BYTE   "EXECUTE"
        0000CB56          = LAST            .SET    THIS
                            EXECUTE:        NATIVE
00CB61  62CB              +                 .WORD   $+1
00CB63  C106              :                 LD      SP+0(MA)        ; Load the data stack
00CB65  32                :                 XPAL    R1
00CB66  C107              :                 LD      SP+1(MA)
00CB68  32                :                 XPAL    R1
00CB69  C200              :                 LD      0(R1)           ; Fetch the word address
00CB6B  01                :                 XAE
00CB6C  C201              :                 LD      1(R1)
00CB6E  36                :                 XPAH    R1
00CB6F  40                :                 LDE
00CB70  32                :                 XPAL    R1
00CB71  C200              :                 LD      0(R1)           ; Fetch the code address
00CB73  01                :                 XAE
00CB74  C201              :                 LD      1(R1)
00CB76  36                :                 XPAH    R1
00CB77  40                :                 LDE
00CB78  32                :                 XPAL    R1
00CB79  A906              :                 ILD     SP+0(MA)        ; Drop the word address
00CB7B  A906              :                 ILD     SP+0(MA)
00CB7D  3E                :                 XPPC    R1              ; And execute the word
                            
                            ; EXIT ( -- ) ( R: nest-sys -- )
                            ;
                            ; Return control to the calling definition specified by nest-sys. Before
                            ; executing EXIT within a do-loop, a program shall discard the loop-control
                            ; parameters by executing UNLOOP.
                            
                                            WORD    "EXIT",NORMAL
        0000CB7E          = THIS            .SET    $
00CB7E  56CB              +                 .WORD   LAST
00CB80  00                +                 .BYTE   NORMAL
00CB81  04                +                 .BYTE   STRLEN("EXIT")
00CB82  45584954          +                 .BYTE   "EXIT"
        0000CB7E          = LAST            .SET    THIS
                            EXIT:           NATIVE
00CB86  87CB              +                 .WORD   $+1
00CB88  C104              :                 LD      RP+0(MA)        ; Load the return stack pointer
00CB8A  32                :                 XPAL    R1
00CB8B  C105              :                 LD      RP+1(MA)
00CB8D  36                :                 XPAH    R1
00CB8E  C200              :                 LD      0(R1)           ; Copy the top cell to the IP

Portable National Semiconductor SC/MP Assembler [16.09]

00CB90  C900              :                 ST      IP+0(MA)
00CB92  C201              :                 LD      1(R1)
00CB94  C901              :                 ST      IP+1(MA)
00CB96  A904              :                 ILD     RP+0(MA)        ; Drop the return address
00CB98  A904              :                 ILD     RP+0(MA)
00CB9A  3F                :                 XPPC    R2              ; And continue
                            
                            ; QUIT ( -- ) ( R: i*x -- )
                            ;
                            ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
                            ; user input device the input source, and enter interpretation state. Do not
                            ; display a message. Repeat the following:
                            ; – Accept a line from the input source into the input buffer, set >IN to zero,
                            ;   and interpret.
                            ; – Display the implementation-defined system prompt if in interpretation state,
                            ;   all processing has been completed, and no ambiguous condition exists.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   DO_QUIT 0 STATE !
                            ;   0 (SOURCE-ID) !
                            ;   BEGIN
                            ;     REFILL
                            ;     WHILE SOURCE EVALUATE
                            ;     STATE @ 0= IF S" Ok" CR TYPE THEN
                            ;   AGAIN ;
                            
                                            WORD    "QUIT",NORMAL
        0000CB9B          = THIS            .SET    $
00CB9B  7ECB              +                 .WORD   LAST
00CB9D  00                +                 .BYTE   NORMAL
00CB9E  04                +                 .BYTE   STRLEN("QUIT")
00CB9F  51554954          +                 .BYTE   "QUIT"
        0000CB9B          = LAST            .SET    THIS
                            QUIT:           FORTH
00CBA3  6ED0              +                 .WORD   DO_COLON-1
00CBA5  D2CB              :                 .WORD   DO_QUIT
00CBA7  DCC0              :                 .WORD   ZERO
00CBA9  C8C0              :                 .WORD   STATE
00CBAB  32C1              :                 .WORD   STORE
00CBAD  DCC0              :                 .WORD   ZERO
00CBAF  BBC0              :                 .WORD   SOURCEID
00CBB1  32C1              :                 .WORD   STORE
00CBB3  51CE              : QUIT_1:         .WORD   REFILL
00CBB5  10D2BBCB          :                 .WORD   QUERY_BRANCH,QUIT_2
00CBB9  8DCD              :                 .WORD   INTERPRET
00CBBB  C8C0              : QUIT_2:         .WORD   STATE
00CBBD  C9C1              :                 .WORD   FETCH
00CBBF  A5C9              :                 .WORD   ZERO_EQUAL
00CBC1  10D2CECB          :                 .WORD   QUERY_BRANCH,QUIT_3
00CBC5  21D3              :                 .WORD   DO_S_QUOTE
00CBC7  024F6B            :                 .BYTE   2,"Ok"
00CBCA  BCD4              :                 .WORD   TYPE
00CBCC  34D4              :                 .WORD   CR

Portable National Semiconductor SC/MP Assembler [16.09]

00CBCE  EFD1B3CB          : QUIT_3:         .WORD   BRANCH,QUIT_1
                            
                            DO_QUIT:        NATIVE
00CBD2  D3CB              +                 .WORD   $+1
00CBD4  C480              :                 LDI     LO(RSTACK_END)  ; Reset the return stack
00CBD6  C904              :                 ST      RP+0(MA)
00CBD8  C411              :                 LDI     HI(RSTACK_END)
00CBDA  C905              :                 ST      RP+1(MA)
00CBDC  3F                :                 XPPC    R2              ; And continue
                            
                            ;===============================================================================
                            ; Parser & Interpreter
                            ;-------------------------------------------------------------------------------
                            
                            ; ?NUMBER
                            ;
                            ;   DUP  0 0 ROT COUNT      -- ca ud adr n
                            ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
                            ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
                            ;   ELSE 2DROP NIP R>
                            ;       IF NEGATE THEN  -1  -- n -1   (ok)
                            ;   THEN ;
                            
                                            WORD    "?NUMBER",NORMAL
        0000CBDD          = THIS            .SET    $
00CBDD  9BCB              +                 .WORD   LAST
00CBDF  00                +                 .BYTE   NORMAL
00CBE0  07                +                 .BYTE   STRLEN("?NUMBER")
00CBE1  3F4E554D424552    +                 .BYTE   "?NUMBER"
        0000CBDD          = LAST            .SET    THIS
                            QUERY_NUMBER:   FORTH
00CBE8  6ED0              +                 .WORD   DO_COLON-1
00CBEA  5DC3              :                 .WORD   DUP
00CBEC  DCC0              :                 .WORD   ZERO
00CBEE  DCC0              :                 .WORD   ZERO
00CBF0  B7C3              :                 .WORD   ROT
00CBF2  CCCF              :                 .WORD   COUNT
00CBF4  25CC              :                 .WORD   QUERY_SIGN
00CBF6  52C4              :                 .WORD   TO_R
00CBF8  6ACC              :                 .WORD   TO_NUMBER
00CBFA  10D20ACC          :                 .WORD   QUERY_BRANCH,QNUM_1
00CBFE  C3C4              :                 .WORD   R_FROM
00CC00  D6C2              :                 .WORD   TWO_DROP
00CC02  D6C2              :                 .WORD   TWO_DROP
00CC04  DCC0              :                 .WORD   ZERO
00CC06  EFD11ACC          :                 .WORD   BRANCH,QNUM_3
00CC0A  D6C2              : QNUM_1:         .WORD   TWO_DROP
00CC0C  77C3              :                 .WORD   NIP
00CC0E  C3C4              :                 .WORD   R_FROM
00CC10  10D216CC          :                 .WORD   QUERY_BRANCH,QNUM_2
00CC14  BAC6              :                 .WORD   NEGATE
00CC16  74D2FFFF          : QNUM_2:         .WORD   DO_LITERAL,-1
00CC1A  86CB              : QNUM_3:         .WORD   EXIT
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; ?SIGN ( c-addr n -- adr' n' f )
                            ;
                            ;   OVER C@                 -- adr n c
                            ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
                            ;   DUP IF 1+               -- +=0, -=+2
                            ;       >R 1 /STRING R>     -- adr' n' f
                            ;   THEN ;
                            
                                            WORD    "?SIGN",NORMAL
        0000CC1C          = THIS            .SET    $
00CC1C  DDCB              +                 .WORD   LAST
00CC1E  00                +                 .BYTE   NORMAL
00CC1F  05                +                 .BYTE   STRLEN("?SIGN")
00CC20  3F5349474E        +                 .BYTE   "?SIGN"
        0000CC1C          = LAST            .SET    THIS
                            QUERY_SIGN:     FORTH
00CC25  6ED0              +                 .WORD   DO_COLON-1
00CC27  87C3              :                 .WORD   OVER
00CC29  3AC2              :                 .WORD   C_FETCH
00CC2B  74D22C00          :                 .WORD   DO_LITERAL,','
00CC2F  67C5              :                 .WORD   MINUS
00CC31  5DC3              :                 .WORD   DUP
00CC33  17C6              :                 .WORD   ABS
00CC35  74D20100          :                 .WORD   DO_LITERAL,1
00CC39  F4C9              :                 .WORD   EQUAL
00CC3B  2CCA              :                 .WORD   AND
00CC3D  5DC3              :                 .WORD   DUP
00CC3F  10D24FCC          :                 .WORD   QUERY_BRANCH,.SKIP
00CC43  B0C5              :                 .WORD   ONE_PLUS
00CC45  52C4              :                 .WORD   TO_R
00CC47  74D20100          :                 .WORD   DO_LITERAL,1
00CC4B  63CF              :                 .WORD   SLASH_STRING
00CC4D  C3C4              :                 .WORD   R_FROM
00CC4F  86CB              : .SKIP           .WORD   EXIT
                            
                            ; >COUNTED ( c-addr n -- )
                            ;
                            ;   2DUP C! CHAR+ SWAP CMOVE
                            
                            TO_COUNTED:     FORTH
00CC51  6ED0              +                 .WORD   DO_COLON-1
00CC53  E9C2              :                 .WORD   TWO_DUP
00CC55  FDC1              :                 .WORD   C_STORE
00CC57  ACC2              :                 .WORD   CHAR_PLUS
00CC59  E4C3              :                 .WORD   SWAP
00CC5B  A5CF              :                 .WORD   CMOVE
00CC5D  86CB              :                 .WORD   EXIT
                            
                            ; >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
                            ;
                            ; ud2 is the unsigned result of converting the characters within the string
                            ; specified by c-addr1 u1 into digits, using the number in BASE, and adding
                            ; each into ud1 after multiplying ud1 by the number in BASE. Conversion
                            ; continues left-to-right until a character that is not convertible, including

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; any “+” or “-”, is encountered or the string is entirely converted. c-addr2
                            ; is the location of the first unconverted character or the first character
                            ; past the end of the string if the string was entirely converted. u2 is the
                            ; number of unconverted characters in the string. An ambiguous condition exists
                            ; if ud2 overflows during the conversion.
                            ;
                            ; In this implementation its is defined as:
                            ;
                            ;   BEGIN
                            ;   DUP WHILE
                            ;       OVER C@ DIGIT?
                            ;       0= IF DROP EXIT THEN
                            ;       >R 2SWAP BASE @ UD*
                            ;       R> M+ 2SWAP
                            ;       1 /STRING
                            ;   REPEAT ;
                            
                                            WORD    ">NUMBER",NORMAL
        0000CC5F          = THIS            .SET    $
00CC5F  1CCC              +                 .WORD   LAST
00CC61  00                +                 .BYTE   NORMAL
00CC62  07                +                 .BYTE   STRLEN(">NUMBER")
00CC63  3E4E554D424552    +                 .BYTE   ">NUMBER"
        0000CC5F          = LAST            .SET    THIS
                            TO_NUMBER:      FORTH
00CC6A  6ED0              +                 .WORD   DO_COLON-1
00CC6C  5DC3              : TO_NUM_1:       .WORD   DUP
00CC6E  10D29CCC          :                 .WORD   QUERY_BRANCH,TO_NUM_3
00CC72  87C3              :                 .WORD   OVER
00CC74  3AC2              :                 .WORD   C_FETCH
00CC76  1ACD              :                 .WORD   DIGIT_QUERY
00CC78  A5C9              :                 .WORD   ZERO_EQUAL
00CC7A  10D282CC          :                 .WORD   QUERY_BRANCH,TO_NUM_2
00CC7E  4FC3              :                 .WORD   DROP
00CC80  86CB              :                 .WORD   EXIT
00CC82  52C4              : TO_NUM_2:       .WORD   TO_R
00CC84  13C3              :                 .WORD   TWO_SWAP
00CC86  7DC0              :                 .WORD   BASE
00CC88  C9C1              :                 .WORD   FETCH
00CC8A  38C9              :                 .WORD   UD_STAR
00CC8C  C3C4              :                 .WORD   R_FROM
00CC8E  CEC8              :                 .WORD   M_PLUS
00CC90  13C3              :                 .WORD   TWO_SWAP
00CC92  74D20100          :                 .WORD   DO_LITERAL,1
00CC96  63CF              :                 .WORD   SLASH_STRING
00CC98  EFD16CCC          :                 .WORD   BRANCH,TO_NUM_1
00CC9C  86CB              : TO_NUM_3:       .WORD   EXIT
                            
                            ; ACCEPT ( c-addr +n1 -- +n2 )
                            ;
                            ; Receive a string of at most +n1 characters. An ambiguous condition exists if
                            ; +n1 is zero or greater than 32,767. Display graphic characters as they are
                            ; received. A program that depends on the presence or absence of non-graphic
                            ; characters in the string has an environmental dependency. The editing

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; functions, if any, that the system performs in order to construct the string
                            ; are implementation-defined.
                            ;
                            ; Input terminates when an implementation-defined line terminator is received.
                            ; When input terminates, nothing is appended to the string, and the display is
                            ; maintained in an implementation-defined way.
                            ;
                            ; +n2 is the length of the string stored at c-addr.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   OVER + 1- OVER      -- sa ea a
                            ;   BEGIN KEY           -- sa ea a c
                            ;   DUP 0D <> WHILE
                            ;     DUP 8 = OVER 127 = OR IF
                            ;       DROP 1-
                            ;       >R OVER R> UMAX
                            ;       8 EMIT SPACE 8 EMIT
                            ;     ELSE
                            ;       DUP EMIT        -- sa ea a c
                            ;       OVER C! 1+ OVER UMIN
                            ;     THEN              -- sa ea a
                            ;   REPEAT              -- sa ea a c
                            ;   DROP NIP SWAP - ;
                            
                                            WORD    "ACCEPT",NORMAL
        0000CC9E          = THIS            .SET    $
00CC9E  5FCC              +                 .WORD   LAST
00CCA0  00                +                 .BYTE   NORMAL
00CCA1  06                +                 .BYTE   STRLEN("ACCEPT")
00CCA2  414343455054      +                 .BYTE   "ACCEPT"
        0000CC9E          = LAST            .SET    THIS
                            ACCEPT:         FORTH
00CCA8  6ED0              +                 .WORD   DO_COLON-1
00CCAA  87C3              :                 .WORD   OVER
00CCAC  48C5              :                 .WORD   PLUS
00CCAE  C0C5              :                 .WORD   ONE_MINUS
00CCB0  87C3              :                 .WORD   OVER
00CCB2  63D4              : ACCEPT_1:       .WORD   KEY
00CCB4  5DC3              :                 .WORD   DUP
00CCB6  74D20D00          :                 .WORD   DO_LITERAL,X'0D
00CCBA  E5C9              :                 .WORD   NOT_EQUAL
00CCBC  10D206CD          :                 .WORD   QUERY_BRANCH,ACCEPT_4
00CCC0  5DC3              :                 .WORD   DUP
00CCC2  74D20800          :                 .WORD   DO_LITERAL,X'08
00CCC6  F4C9              :                 .WORD   EQUAL
00CCC8  87C3              :                 .WORD   OVER
00CCCA  74D27F00          :                 .WORD   DO_LITERAL,X'7f
00CCCE  F4C9              :                 .WORD   EQUAL
00CCD0  91CA              :                 .WORD   OR
00CCD2  10D2F4CC          :                 .WORD   QUERY_BRANCH,ACCEPT_2
00CCD6  4FC3              :                 .WORD   DROP
00CCD8  C0C5              :                 .WORD   ONE_MINUS
00CCDA  52C4              :                 .WORD   TO_R

Portable National Semiconductor SC/MP Assembler [16.09]

00CCDC  87C3              :                 .WORD   OVER
00CCDE  C3C4              :                 .WORD   R_FROM
00CCE0  D8C6              :                 .WORD   UMAX
00CCE2  74D20800          :                 .WORD   DO_LITERAL,8
00CCE6  4CD4              :                 .WORD   EMIT
00CCE8  8AD4              :                 .WORD   SPACE
00CCEA  74D20800          :                 .WORD   DO_LITERAL,8
00CCEE  4CD4              :                 .WORD   EMIT
00CCF0  EFD102CD          :                 .WORD   BRANCH,ACCEPT_3
00CCF4  5DC3              : ACCEPT_2:       .WORD   DUP
00CCF6  4CD4              :                 .WORD   EMIT
00CCF8  87C3              :                 .WORD   OVER
00CCFA  FDC1              :                 .WORD   C_STORE
00CCFC  B0C5              :                 .WORD   ONE_PLUS
00CCFE  87C3              :                 .WORD   OVER
00CD00  F0C6              :                 .WORD   UMIN
00CD02  EFD1B2CC          : ACCEPT_3:       .WORD   BRANCH,ACCEPT_1
00CD06  4FC3              : ACCEPT_4:       .WORD   DROP
00CD08  77C3              :                 .WORD   NIP
00CD0A  E4C3              :                 .WORD   SWAP
00CD0C  67C5              :                 .WORD   MINUS
00CD0E  86CB              :                 .WORD   EXIT
                            
                            ; DIGIT?
                            ;
                            ;   [ HEX ] DUP 39 > 100 AND +     silly looking
                            ;   DUP 140 > 107 AND -   30 -     but it works!
                            ;   DUP BASE @ U< ;
                            
                                            WORD    "DIGIT?",NORMAL
        0000CD10          = THIS            .SET    $
00CD10  9ECC              +                 .WORD   LAST
00CD12  00                +                 .BYTE   NORMAL
00CD13  06                +                 .BYTE   STRLEN("DIGIT?")
00CD14  44494749543F      +                 .BYTE   "DIGIT?"
        0000CD10          = LAST            .SET    THIS
                            DIGIT_QUERY:    FORTH
00CD1A  6ED0              +                 .WORD   DO_COLON-1
00CD1C  5DC3              :                 .WORD   DUP
00CD1E  74D23900          :                 .WORD   DO_LITERAL,'9'
00CD22  01CA              :                 .WORD   GREATER
00CD24  74D20001          :                 .WORD   DO_LITERAL,X'100
00CD28  2CCA              :                 .WORD   AND
00CD2A  48C5              :                 .WORD   PLUS
00CD2C  5DC3              :                 .WORD   DUP
00CD2E  74D24001          :                 .WORD   DO_LITERAL,X'140
00CD32  01CA              :                 .WORD   GREATER
00CD34  74D20701          :                 .WORD   DO_LITERAL,X'107
00CD38  2CCA              :                 .WORD   AND
00CD3A  67C5              :                 .WORD   MINUS
00CD3C  74D23000          :                 .WORD   DO_LITERAL,'0'
00CD40  67C5              :                 .WORD   MINUS
00CD42  5DC3              :                 .WORD   DUP
00CD44  7DC0              :                 .WORD   BASE

Portable National Semiconductor SC/MP Assembler [16.09]

00CD46  C9C1              :                 .WORD   FETCH
00CD48  0FCA              :                 .WORD   U_LESS
00CD4A  86CB              :                 .WORD   EXIT
                            
                            ; EVALUATE ( i*x c-addr u -- j*x )
                            ;
                            ; Save the current input source specification. Store minus-one (-1) in
                            ; SOURCE-ID if it is present. Make the string described by c-addr and u both
                            ; the input source and input buffer, set >IN to zero, and interpret. When the
                            ; parse area is empty, restore the prior input source specification. Other
                            ; stack effects are due to the words EVALUATEd.
                            ;
                            ;   >R >R SAVE-INPUT
                            ;   -1 (SOURCE-ID) !
                            ;   0 >IN ! (LENGTH) ! (BUFFER) !
                            ;   INTERPRET
                            ;   RESTORE-INPUT DROP
                            
                                            WORD    "EVALUATE",NORMAL
        0000CD4C          = THIS            .SET    $
00CD4C  10CD              +                 .WORD   LAST
00CD4E  00                +                 .BYTE   NORMAL
00CD4F  08                +                 .BYTE   STRLEN("EVALUATE")
00CD50  4556414C55415445  +                 .BYTE   "EVALUATE"
        0000CD4C          = LAST            .SET    THIS
                            EVALUATE:       FORTH
00CD58  6ED0              +                 .WORD   DO_COLON-1
00CD5A  52C4              :                 .WORD   TO_R
00CD5C  52C4              :                 .WORD   TO_R
00CD5E  B5CE              :                 .WORD   SAVE_INPUT
00CD60  C3C4              :                 .WORD   R_FROM
00CD62  C3C4              :                 .WORD   R_FROM
00CD64  FFC0              :                 .WORD   TRUE
00CD66  BBC0              :                 .WORD   SOURCEID
00CD68  32C1              :                 .WORD   STORE
00CD6A  DCC0              :                 .WORD   ZERO
00CD6C  71C0              :                 .WORD   TO_IN
00CD6E  32C1              :                 .WORD   STORE
00CD70  ACC0              :                 .WORD   LENGTH
00CD72  32C1              :                 .WORD   STORE
00CD74  8CC0              :                 .WORD   BUFFER
00CD76  32C1              :                 .WORD   STORE
00CD78  8DCD              :                 .WORD   INTERPRET
00CD7A  8ECE              :                 .WORD   RESTORE_INPUT
00CD7C  4FC3              :                 .WORD   DROP
00CD7E  86CB              :                 .WORD   EXIT
                            
                            ; INTERPRET ( -- )
                            ;
                            ;
                            ;   BEGIN
                            ;   BL WORD DUP C@ WHILE        -- textadr
                            ;       FIND                    -- a 0/1/-1
                            ;       ?DUP IF                 -- xt 1/-1

Portable National Semiconductor SC/MP Assembler [16.09]

                            ;           1+ STATE @ 0= OR    immed or interp?
                            ;           IF EXECUTE ELSE , THEN
                            ;       ELSE                    -- textadr
                            ;           ?NUMBER
                            ;           IF STATE @
                            ;               IF POSTPONE LITERAL THEN     converted ok
                            ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
                            ;           THEN
                            ;       THEN
                            ;   REPEAT DROP ;
                            
                                            WORD    "INTERPRET",NORMAL
        0000CD80          = THIS            .SET    $
00CD80  4CCD              +                 .WORD   LAST
00CD82  00                +                 .BYTE   NORMAL
00CD83  09                +                 .BYTE   STRLEN("INTERPRET")
00CD84  494E544552505245> +                 .BYTE   "INTERPRET"
        0000CD80          = LAST            .SET    THIS
                            INTERPRET:      FORTH
00CD8D  6ED0              +                 .WORD   DO_COLON-1
00CD8F  E6C0              : INTERPRET_1:    .WORD   BL
00CD91  02CF              :                 .WORD   WORD
00CD93  5DC3              :                 .WORD   DUP
00CD95  3AC2              :                 .WORD   C_FETCH
00CD97  10D2E3CD          :                 .WORD   QUERY_BRANCH,INTERPRET_7
00CD9B  EFCD              :                 .WORD   FIND
00CD9D  1FC3              :                 .WORD   QUERY_DUP
00CD9F  10D2BDCD          :                 .WORD   QUERY_BRANCH,INTERPRET_4
00CDA3  B0C5              :                 .WORD   ONE_PLUS
00CDA5  C8C0              :                 .WORD   STATE
00CDA7  C9C1              :                 .WORD   FETCH
00CDA9  A5C9              :                 .WORD   ZERO_EQUAL
00CDAB  91CA              :                 .WORD   OR
00CDAD  10D2B7CD          :                 .WORD   QUERY_BRANCH,INTERPRET_2
00CDB1  61CB              :                 .WORD   EXECUTE
00CDB3  EFD1B9CD          :                 .WORD   BRANCH,INTERPRET_3
00CDB7  8CC1              : INTERPRET_2:    .WORD   COMMA
00CDB9  EFD1DFCD          : INTERPRET_3:    .WORD   BRANCH,INTERPRET_6
00CDBD  E8CB              : INTERPRET_4:    .WORD   QUERY_NUMBER
00CDBF  10D2D1CD          :                 .WORD   QUERY_BRANCH,INTERPRET_5
00CDC3  C8C0              :                 .WORD   STATE
00CDC5  C9C1              :                 .WORD   FETCH
00CDC7  10D2DFCD          :                 .WORD   QUERY_BRANCH,INTERPRET_6
00CDCB  68D2              :                 .WORD   LITERAL
00CDCD  EFD1DFCD          :                 .WORD   BRANCH,INTERPRET_6
00CDD1  CCCF              : INTERPRET_5:    .WORD   COUNT
00CDD3  BCD4              :                 .WORD   TYPE
00CDD5  74D23F00          :                 .WORD   DO_LITERAL,X'3f
00CDD9  4CD4              :                 .WORD   EMIT
00CDDB  34D4              :                 .WORD   CR
00CDDD  15CB              :                 .WORD   ABORT
00CDDF  EFD18FCD          : INTERPRET_6     .WORD   BRANCH,INTERPRET_1
00CDE3  4FC3              : INTERPRET_7:    .WORD   DROP
00CDE5  86CB              :                 .WORD   EXIT

Portable National Semiconductor SC/MP Assembler [16.09]

                            
                            ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
                            ;
                            ; Find the definition named in the counted string at c-addr. If the definition
                            ; is not found, return c-addr and zero. If the definition is found, return its
                            ; execution token xt. If the definition is immediate, also return one (1),
                            ; otherwise also return minus-one (-1). For a given string, the values returned
                            ; by FIND while compiling may differ from those returned while not compiling.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   LATEST @ BEGIN             -- a nfa
                            ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
                            ;       S=                     -- a nfa f
                            ;       DUP IF
                            ;           DROP
                            ;           NFA>LFA @ DUP      -- a link link
                            ;       THEN
                            ;   0= UNTIL                   -- a nfa  OR  a 0
                            ;   DUP IF
                            ;       NIP DUP NFA>CFA        -- nfa xt
                            ;       SWAP IMMED?            -- xt iflag
                            ;       0= 1 OR                -- xt 1/-1
                            ;   THEN ;
                            
                                            WORD    "FIND",NORMAL
        0000CDE7          = THIS            .SET    $
00CDE7  80CD              +                 .WORD   LAST
00CDE9  00                +                 .BYTE   NORMAL
00CDEA  04                +                 .BYTE   STRLEN("FIND")
00CDEB  46494E44          +                 .BYTE   "FIND"
        0000CDE7          = LAST            .SET    THIS
                            FIND:           FORTH
00CDEF  6ED0              +                 .WORD   DO_COLON-1
00CDF1  A8C0              :                 .WORD   LATEST
00CDF3  C9C1              :                 .WORD   FETCH
00CDF5  E9C2              : FIND1:          .WORD   TWO_DUP
00CDF7  87C3              :                 .WORD   OVER
00CDF9  3AC2              :                 .WORD   C_FETCH
00CDFB  ACC2              :                 .WORD   CHAR_PLUS
00CDFD  A4CE              :                 .WORD   S_EQUAL
00CDFF  5DC3              :                 .WORD   DUP
00CE01  10D20DCE          :                 .WORD   QUERY_BRANCH,FIND2
00CE05  4FC3              :                 .WORD   DROP
00CE07  3DCE              :                 .WORD   NFA_TO_LFA
00CE09  C9C1              :                 .WORD   FETCH
00CE0B  5DC3              :                 .WORD   DUP
00CE0D  A5C9              : FIND2:          .WORD   ZERO_EQUAL
00CE0F  10D2F5CD          :                 .WORD   QUERY_BRANCH,FIND1
00CE13  5DC3              :                 .WORD   DUP
00CE15  10D22BCE          :                 .WORD   QUERY_BRANCH,FIND3
00CE19  77C3              :                 .WORD   NIP
00CE1B  5DC3              :                 .WORD   DUP
00CE1D  35CE              :                 .WORD   NFA_TO_CFA

Portable National Semiconductor SC/MP Assembler [16.09]

00CE1F  E4C3              :                 .WORD   SWAP
00CE21  2DCE              :                 .WORD   IMMED_QUERY
00CE23  A5C9              :                 .WORD   ZERO_EQUAL
00CE25  74D20100          :                 .WORD   DO_LITERAL,1
00CE29  91CA              :                 .WORD   OR
00CE2B  86CB              : FIND3:          .WORD   EXIT
                            
                            ; IMMED? ( nfa -- f )
                            
                            IMMED_QUERY:    FORTH
00CE2D  6ED0              +                 .WORD   DO_COLON-1
00CE2F  C0C5              :                 .WORD   ONE_MINUS
00CE31  3AC2              :                 .WORD   C_FETCH
00CE33  86CB              :                 .WORD   EXIT
                            
                            ; NFA>CFA ( nfa -- cfa )
                            
                            NFA_TO_CFA:     FORTH
00CE35  6ED0              +                 .WORD   DO_COLON-1
00CE37  CCCF              :                 .WORD   COUNT
00CE39  48C5              :                 .WORD   PLUS
00CE3B  86CB              :                 .WORD   EXIT
                            
                            ; NFA>LFA ( nfa -- lfa )
                            
                            NFA_TO_LFA:     FORTH
00CE3D  6ED0              +                 .WORD   DO_COLON-1
00CE3F  74D20300          :                 .WORD   DO_LITERAL,3
00CE43  67C5              :                 .WORD   MINUS
00CE45  86CB              :                 .WORD   EXIT
                            
                            ; REFILL ( -- flag )
                            ;
                            ; Attempt to fill the input buffer from the input source, returning a true flag
                            ; if successful.
                            ;
                            ; When the input source is the user input device, attempt to receive input into
                            ; the terminal input buffer. If successful, make the result the input buffer,
                            ; set >IN to zero, and return true. Receipt of a line containing no characters
                            ; is considered successful. If there is no input available from the current
                            ; input source, return false.
                            ;
                            ; When the input source is a string from EVALUATE, return false and perform no
                            ; other action.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   SOURCE-ID 0= IF
                            ;     TIB DUP #TIB @ ACCEPT SPACE
                            ;     LENGTH ! BUFFER !
                            ;     0 >IN ! TRUE EXIT
                            ;   THEN
                            ;   FALSE
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                                            WORD    "REFILL",NORMAL
        0000CE47          = THIS            .SET    $
00CE47  E7CD              +                 .WORD   LAST
00CE49  00                +                 .BYTE   NORMAL
00CE4A  06                +                 .BYTE   STRLEN("REFILL")
00CE4B  524546494C4C      +                 .BYTE   "REFILL"
        0000CE47          = LAST            .SET    THIS
                            REFILL:         FORTH
00CE51  6ED0              +                 .WORD   DO_COLON-1
00CE53  F2CE              :                 .WORD   SOURCE_ID
00CE55  A5C9              :                 .WORD   ZERO_EQUAL
00CE57  10D279CE          :                 .WORD   QUERY_BRANCH,REFILL_1
00CE5B  D3C0              :                 .WORD   TIB
00CE5D  5DC3              :                 .WORD   DUP
00CE5F  64C0              :                 .WORD   HASH_TIB
00CE61  C9C1              :                 .WORD   FETCH
00CE63  A8CC              :                 .WORD   ACCEPT
00CE65  8AD4              :                 .WORD   SPACE
00CE67  ACC0              :                 .WORD   LENGTH
00CE69  32C1              :                 .WORD   STORE
00CE6B  8CC0              :                 .WORD   BUFFER
00CE6D  32C1              :                 .WORD   STORE
00CE6F  DCC0              :                 .WORD   ZERO
00CE71  71C0              :                 .WORD   TO_IN
00CE73  32C1              :                 .WORD   STORE
00CE75  FFC0              :                 .WORD   TRUE
00CE77  86CB              :                 .WORD   EXIT
00CE79  F3C0              : REFILL_1:       .WORD   FALSE
00CE7B  86CB              :                 .WORD   EXIT
                            
                            ; RESTORE-INPUT ( xn ... x1 n -- flag )
                            ;
                            ; Attempt to restore the input source specification to the state described by
                            ; x1 through xn. flag is true if the input source specification cannot be so
                            ; restored.
                            ;
                            ; An ambiguous condition exists if the input source represented by the
                            ; arguments is not the same as the current input source.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   >IN ! (LENGTH) ! BUFFER !
                            ;   SOURCEID !
                            ;   TRUE
                            
                                            WORD    "RESTORE-INPUT",NORMAL
        0000CE7D          = THIS            .SET    $
00CE7D  47CE              +                 .WORD   LAST
00CE7F  00                +                 .BYTE   NORMAL
00CE80  0D                +                 .BYTE   STRLEN("RESTORE-INPUT")
00CE81  524553544F52452D> +                 .BYTE   "RESTORE-INPUT"
        0000CE7D          = LAST            .SET    THIS
                            RESTORE_INPUT   FORTH
00CE8E  6ED0              +                 .WORD   DO_COLON-1

Portable National Semiconductor SC/MP Assembler [16.09]

00CE90  71C0              :                 .WORD   TO_IN
00CE92  32C1              :                 .WORD   STORE
00CE94  ACC0              :                 .WORD   LENGTH
00CE96  32C1              :                 .WORD   STORE
00CE98  8CC0              :                 .WORD   BUFFER
00CE9A  32C1              :                 .WORD   STORE
00CE9C  BBC0              :                 .WORD   SOURCEID
00CE9E  32C1              :                 .WORD   STORE
00CEA0  FFC0              :                 .WORD   TRUE
00CEA2  86CB              :                 .WORD   EXIT
                            
                            ; S= ( c-addr1 caddr2 u -- n)
                            ;
                            ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
                            
                            S_EQUAL:        NATIVE
00CEA4  A5CE              +                 .WORD   $+1
                                    .IF 0
                            ;                phy
                            ;                ldx     <1                      ; Fetch maximum length
                            ;                beq     S_EQUAL_3
                            ;                ldy     #0
                            ;                short_a
                            ;S_EQUAL_1:
                            ;                lda     (5),y                   ; Compare bytes
                            ;                cmp     (3),y
                            ;                bne     S_EQUAL_2
                            ;                iny
                            ;                dex                             ; End of strings?
                            ;                bne     S_EQUAL_1               ; No
                            ;                bra     S_EQUAL_3               ; Yes. must be the same
                            ;S_EQUAL_2:
                            ;                ldx     #$ffff                  ; Difference found
                            ;S_EQUAL_3:
                          -  ;               long_a
                            ;                tdc                             ; Clean up the stack
                            ;                inc     a
                            ;                inc     a
                            ;                inc     a
                            ;                inc     a
                            ;                tcd
                            ;                stx     <1                      ; Save the flag
                            ;                ply
                            ;                CONTINUE
                                    .ENDIF
00CEA6  3F                :                 XPPC    R2              ; And continue
                            
                            ; SAVE-INPUT ( -- xn ... x1 n )
                            ;
                            ; x1 through xn describe the current state of the input source specification
                            ; for later use by RESTORE-INPUT.
                            
                                            WORD    "SAVE-INPUT",NORMAL
        0000CEA7          = THIS            .SET    $

Portable National Semiconductor SC/MP Assembler [16.09]

00CEA7  7DCE              +                 .WORD   LAST
00CEA9  00                +                 .BYTE   NORMAL
00CEAA  0A                +                 .BYTE   STRLEN("SAVE-INPUT")
00CEAB  534156452D494E50> +                 .BYTE   "SAVE-INPUT"
        0000CEA7          = LAST            .SET    THIS
                            SAVE_INPUT:     FORTH
00CEB5  6ED0              +                 .WORD   DO_COLON-1
00CEB7  BBC0              :                 .WORD   SOURCEID
00CEB9  C9C1              :                 .WORD   FETCH
00CEBB  8CC0              :                 .WORD   BUFFER
00CEBD  C9C1              :                 .WORD   FETCH
00CEBF  ACC0              :                 .WORD   LENGTH
00CEC1  C9C1              :                 .WORD   FETCH
00CEC3  71C0              :                 .WORD   TO_IN
00CEC5  C9C1              :                 .WORD   FETCH
00CEC7  86CB              :                 .WORD   EXIT
                            
                            ; SCAN ( c-addr n c == c-addr' n' )
                            
                            SCAN:           NATIVE
00CEC9  CACE              +                 .WORD   $+1
                                    .IF 0
                            ;SCAN_1:
                            ;                lda     <3                      ; Any data left to scan?
                            ;                beq     SCAN_2                  ; No.
                            ;                lda     <1                      ; Fetch and compare with scan
                            ;                short_a
                            ;                cmp     (5)
                            ;                long_a
                            ;                beq     SCAN_2
                            ;                inc     <5
                            ;                dec     <3
                            ;                bra     SCAN_1
                            ;SCAN_2:
                            ;                jmp     DROP                    ; Drop the character
                                    .ENDIF
00CECB  3F                :                 XPPC    R2              ; And continue
                            
                            ; SKIP ( c-addr n c == c-addr' n' )
                            
                            SKIP:           NATIVE
00CECC  CDCE              +                 .WORD   $+1
                                    .IF 0
                            ;SKIP_1:         lda     <3                      ; Any data left to skip over?
                            ;                beq     SKIP_2                  ; No.
                            ;                lda     <1                      ; Fetch and compare with skip
                            ;                short_a
                            ;                cmp     (5)
                            ;                long_a
                            ;                bne     SKIP_2                  ; Cannot be skipped
                            ;                inc     <5                      ; Bump data address
                            ;                dec     <3                      ; and update length
                            ;                bra     SKIP_1                  ; And repeat
                            ;SKIP_2:

Portable National Semiconductor SC/MP Assembler [16.09]

                            ;                jmp     DROP                    ; Drop the character
                                    .ENDIF
00CECE  3F                :                 XPPC    R2              ; And continue
                            
                            ; SOURCE ( -- c-addr u )
                            ;
                            ; c-addr is the address of, and u is the number of characters in, the input
                            ; buffer.
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   BUFFER @ LENGTH @
                            
                                            WORD    "SOURCE",NORMAL
        0000CECF          = THIS            .SET    $
00CECF  A7CE              +                 .WORD   LAST
00CED1  00                +                 .BYTE   NORMAL
00CED2  06                +                 .BYTE   STRLEN("SOURCE")
00CED3  534F55524345      +                 .BYTE   "SOURCE"
        0000CECF          = LAST            .SET    THIS
                            SOURCE:         FORTH
00CED9  6ED0              +                 .WORD   DO_COLON-1
00CEDB  8CC0              :                 .WORD   BUFFER
00CEDD  C9C1              :                 .WORD   FETCH
00CEDF  ACC0              :                 .WORD   LENGTH
00CEE1  C9C1              :                 .WORD   FETCH
00CEE3  86CB              :                 .WORD   EXIT
                            
                            ; SOURCE-ID ( -- 0 | -1 )
                            ;
                            ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
                            ; device.
                            
                                            WORD    "SOURCE-ID",NORMAL
        0000CEE5          = THIS            .SET    $
00CEE5  CFCE              +                 .WORD   LAST
00CEE7  00                +                 .BYTE   NORMAL
00CEE8  09                +                 .BYTE   STRLEN("SOURCE-ID")
00CEE9  534F555243452D49> +                 .BYTE   "SOURCE-ID"
        0000CEE5          = LAST            .SET    THIS
                            SOURCE_ID:      FORTH
00CEF2  6ED0              +                 .WORD   DO_COLON-1
00CEF4  BBC0              :                 .WORD   SOURCEID
00CEF6  C9C1              :                 .WORD   FETCH
00CEF8  86CB              :                 .WORD   EXIT
                            
                            ; WORD ( char “<chars>ccc<char>” -- c-addr )
                            ;
                            ; Skip leading delimiters. Parse characters ccc delimited by char. An
                            ; ambiguous condition exists if the length of the parsed string is greater
                            ; than the implementation-defined length of a counted string.
                            ;
                            ; c-addr is the address of a transient region containing the parsed word as
                            ; a counted string. If the parse area was empty or contained no characters

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; other than the delimiter, the resulting string has a zero length. A space,
                            ; not included in the length, follows the string. A program may replace
                            ; characters within the string.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
                            ;   DUP >R   ROT SKIP           -- c adr' n'
                            ;   OVER >R  ROT SCAN           -- adr" n"
                            ;   DUP IF CHAR- THEN        skip trailing delim.
                            ;   R> R> ROT -   >IN +!        update >IN offset
                            ;   TUCK -                      -- adr' N
                            ;   HERE >counted               --
                            ;   HERE                        -- a
                            ;   BL OVER COUNT + C! ;    append trailing blank
                            
                                            WORD    "WORD",NORMAL
        0000CEFA          = THIS            .SET    $
00CEFA  E5CE              +                 .WORD   LAST
00CEFC  00                +                 .BYTE   NORMAL
00CEFD  04                +                 .BYTE   STRLEN("WORD")
00CEFE  574F5244          +                 .BYTE   "WORD"
        0000CEFA          = LAST            .SET    THIS
                            WORD:           FORTH
00CF02  6ED0              +                 .WORD   DO_COLON-1
00CF04  5DC3              :                 .WORD   DUP
00CF06  D9CE              :                 .WORD   SOURCE
00CF08  71C0              :                 .WORD   TO_IN
00CF0A  C9C1              :                 .WORD   FETCH
00CF0C  63CF              :                 .WORD   SLASH_STRING
00CF0E  5DC3              :                 .WORD   DUP
00CF10  52C4              :                 .WORD   TO_R
00CF12  B7C3              :                 .WORD   ROT
00CF14  CCCE              :                 .WORD   SKIP
00CF16  87C3              :                 .WORD   OVER
00CF18  52C4              :                 .WORD   TO_R
00CF1A  B7C3              :                 .WORD   ROT
00CF1C  C9CE              :                 .WORD   SCAN
00CF1E  5DC3              :                 .WORD   DUP
00CF20  10D226CF          :                 .WORD   QUERY_BRANCH,WORD_1
00CF24  BBC2              :                 .WORD   CHAR_MINUS
00CF26  C3C4              : WORD_1:         .WORD   R_FROM
00CF28  C3C4              :                 .WORD   R_FROM
00CF2A  B7C3              :                 .WORD   ROT
00CF2C  67C5              :                 .WORD   MINUS
00CF2E  71C0              :                 .WORD   TO_IN
00CF30  5DC1              :                 .WORD   PLUS_STORE
00CF32  09C4              :                 .WORD   TUCK
00CF34  67C5              :                 .WORD   MINUS
00CF36  5FC2              :                 .WORD   HERE
00CF38  51CC              :                 .WORD   TO_COUNTED
00CF3A  5FC2              :                 .WORD   HERE
00CF3C  E6C0              :                 .WORD   BL
00CF3E  87C3              :                 .WORD   OVER

Portable National Semiconductor SC/MP Assembler [16.09]

00CF40  CCCF              :                 .WORD   COUNT
00CF42  48C5              :                 .WORD   PLUS
00CF44  FDC1              :                 .WORD   C_STORE
00CF46  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; String Words
                            ;-------------------------------------------------------------------------------
                            
                            ; -TRAILING ( c-addr u1 -- c-addr u2 )
                            ;
                            ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
                            ; the end of the character string specified by c-addr u1. If u1 is zero or the
                            ; entire string consists of spaces, u2 is zero.
                            
                                            WORD    "-TRAILING",NORMAL
        0000CF48          = THIS            .SET    $
00CF48  FACE              +                 .WORD   LAST
00CF4A  00                +                 .BYTE   NORMAL
00CF4B  09                +                 .BYTE   STRLEN("-TRAILING")
00CF4C  2D545241494C494E> +                 .BYTE   "-TRAILING"
        0000CF48          = LAST            .SET    THIS
                            DASH_TRAILING:  NATIVE
00CF55  56CF              +                 .WORD   $+1
                                    .IF 0
                            ;                phy                             ; Save IP
                            ;                ldy     <1                      ; Is u1 > 0?
                            ;                beq     DASH_TRAIL_3            ; No
                            ;                short_a
                            ;                dey                             ; Convert to offset
                            ;DASH_TRAIL_1:   lda     (3),y                   ; Space character at end?
                            ;                cmp     #' '
                            ;                bne     DASH_TRAIL_2            ; No
                            ;                dey                             ; More characters to check?
                            ;                bpl     DASH_TRAIL_1            ; Yes
                            ;DASH_TRAIL_2:   long_a
                            ;                iny                             ; Convert to length
                            ;DASH_TRAIL_3:   sty     <1                      ; Update
                            ;                ply                             ; Restore IP
                            ;                CONTINUE                        ; Done
                                    .ENDIF
00CF57  3F                :                 XPPC    R2
                            
                            ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
                            ;
                            ; Adjust the character string at c-addr1 by n characters. The resulting
                            ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
                            ; characters and is u1 minus n characters long.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   ROT OVER + ROT ROT -
                            
                                            WORD    "/STRING",NORMAL

Portable National Semiconductor SC/MP Assembler [16.09]

        0000CF58          = THIS            .SET    $
00CF58  48CF              +                 .WORD   LAST
00CF5A  00                +                 .BYTE   NORMAL
00CF5B  07                +                 .BYTE   STRLEN("/STRING")
00CF5C  2F535452494E47    +                 .BYTE   "/STRING"
        0000CF58          = LAST            .SET    THIS
                            SLASH_STRING:   FORTH
00CF63  6ED0              +                 .WORD   DO_COLON-1
00CF65  B7C3              :                 .WORD   ROT
00CF67  87C3              :                 .WORD   OVER
00CF69  48C5              :                 .WORD   PLUS
00CF6B  B7C3              :                 .WORD   ROT
00CF6D  B7C3              :                 .WORD   ROT
00CF6F  67C5              :                 .WORD   MINUS
00CF71  86CB              :                 .WORD   EXIT
                            
                            ; BLANK ( c-addr u -- )
                            ;
                            ; If u is greater than zero, store the character value for space in u
                            ; consecutive character positions beginning at c-addr.
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
                            
                                            WORD    "BLANK",NORMAL
        0000CF73          = THIS            .SET    $
00CF73  58CF              +                 .WORD   LAST
00CF75  00                +                 .BYTE   NORMAL
00CF76  05                +                 .BYTE   STRLEN("BLANK")
00CF77  424C414E4B        +                 .BYTE   "BLANK"
        0000CF73          = LAST            .SET    THIS
                            BLANK:          FORTH
00CF7C  6ED0              +                 .WORD   DO_COLON-1
00CF7E  1FC3              :                 .WORD   QUERY_DUP
00CF80  10D298CF          :                 .WORD   QUERY_BRANCH,BLANK_2
00CF84  87C3              :                 .WORD   OVER
00CF86  48C5              :                 .WORD   PLUS
00CF88  E4C3              :                 .WORD   SWAP
00CF8A  CED1              :                 .WORD   DO_DO
00CF8C  E6C0              : BLANK_1:        .WORD   BL
00CF8E  7AC4              :                 .WORD   I
00CF90  FDC1              :                 .WORD   C_STORE
00CF92  97D28CCF          :                 .WORD   DO_LOOP,BLANK_1
00CF96  86CB              :                 .WORD   EXIT
00CF98  4FC3              : BLANK_2:        .WORD   DROP
00CF9A  86CB              :                 .WORD   EXIT
                            
                            ; CMOVE ( c-addr1 c-addr2 u -- )
                            ;
                            ; If u is greater than zero, copy u consecutive characters from the data space
                            ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
                            ; character from lower addresses to higher addresses.
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                                            WORD    "CMOVE",NORMAL
        0000CF9C          = THIS            .SET    $
00CF9C  73CF              +                 .WORD   LAST
00CF9E  00                +                 .BYTE   NORMAL
00CF9F  05                +                 .BYTE   STRLEN("CMOVE")
00CFA0  434D4F5645        +                 .BYTE   "CMOVE"
        0000CF9C          = LAST            .SET    THIS
                            CMOVE:          NATIVE
00CFA5  A6CF              +                 .WORD   $+1
                                    .IF 0
                            ;                phy
                            ;                ldx     <1                      ; Any characters to move?
                            ;                beq     CMOVE_2                 ; No
                            ;                ldy     #0
                            ;                short_a
                            ;CMOVE_1:                                        ; Transfer a byte
                            ;                lda     (5),y
                            ;                sta     (3),y
                            ;                iny
                            ;                dex                             ; Decrement count
                            ;                bne     CMOVE_1                 ; .. and repeat until done
                            ;                long_a;
                            ;CMOVE_2:
                            ;                tdc                             ; Clean up the stack
                            ;                clc
                            ;                adc     #6
                            ;                tcd
                            ;                ply
                            ;                CONTINUE                        ; Done
                                    .ENDIF
00CFA7  3F                :                 XPPC    R2
                            
                            ; CMOVE> ( c-addr1 c-addr2 u -- )
                            ;
                            ; If u is greater than zero, copy u consecutive characters from the data space
                            ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
                            ; character from higher addresses to lower addresses.
                            
                                            WORD    "CMOVE>",NORMAL
        0000CFA8          = THIS            .SET    $
00CFA8  9CCF              +                 .WORD   LAST
00CFAA  00                +                 .BYTE   NORMAL
00CFAB  06                +                 .BYTE   STRLEN("CMOVE>")
00CFAC  434D4F56453E      +                 .BYTE   "CMOVE>"
        0000CFA8          = LAST            .SET    THIS
                            CMOVE_GREATER:  NATIVE
00CFB2  B3CF              +                 .WORD   $+1
                                    .IF 0
                            ;                phy
                            ;                ldx     <1                      ; Any characters to move?
                            ;                beq     CMOVE_GT_2              ; No.
                            ;                ldy     <1
                            ;                short_a
                            ;CMOVE_GT_1:

Portable National Semiconductor SC/MP Assembler [16.09]

                            ;                dey                             ; Transfer a byte
                            ;                lda     (5),y
                            ;                sta     (3),y
                            ;                dex                             ; Decrement length
                            ;                bne     CMOVE_GT_1              ; .. and repeat until done
                            ;                long_a
                            ;CMOVE_GT_2:
                            ;                tdc                             ; Clean up the stack
                            ;                clc
                            ;                adc     #6;
                            ;                tcd
                            ;                ply
                            ;                CONTINUE                        ; Done
                                    .ENDIF
00CFB4  3F                :                 XPPC    R2
                            
                            ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
                            ;
                            ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
                            ; u2. The strings are compared, beginning at the given addresses, character by
                            ; character, up to the length of the shorter string or until a difference is
                            ; found. If the two strings are identical, n is zero. If the two strings are
                            ; identical up to the length of the shorter string, n is minus-one (-1) if u1
                            ; is less than u2 and one (1) otherwise. If the two strings are not identical
                            ; up to the length of the shorter string, n is minus-one (-1) if the first
                            ; non-matching character in the string specified by c-addr1 u1 has a lesser
                            ; numeric value than the corresponding character in the string specified by
                            ; c-addr2 u2 and one (1) otherwise.
                            
                                            WORD    "COMPARE",NORMAL
        0000CFB5          = THIS            .SET    $
00CFB5  A8CF              +                 .WORD   LAST
00CFB7  00                +                 .BYTE   NORMAL
00CFB8  07                +                 .BYTE   STRLEN("COMPARE")
00CFB9  434F4D50415245    +                 .BYTE   "COMPARE"
        0000CFB5          = LAST            .SET    THIS
                            COMPARE:        NATIVE
00CFC0  C1CF              +                 .WORD   $+1
                                    .IF 0
                            ;                lda     <1                      ; Both string lengths zero?
                            ;                ora     <5
                            ;                beq     COMPARE_X               ; Yes, must be equal;
                            ;
                            ;                lda     <1                      ; Second string length zero?
                            ;                beq     COMPARE_P               ; Yes, must be shorter
                            ;                lda     <5                      ; First string length zero?
                            ;                beq     COMPARE_N               ; Yes, must be shorter
                            ;                short_a
                            ;                lda     (7)                     ; Compare next characters
                            ;                cmp     (3)
                            ;                long_a
                            ;               bcc     COMPARE_N
                            ;                bne     COMPARE_P
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                            ;                inc     <3                      ; Bump string pointers
                            ;                inc     <7
                            ;                dec     <1                      ; And reduce lengths
                            ;                dec     <5
                            ;                bra     COMPARE
                            
                            ;COMPARE_P:      lda     #1
                            ;                bra     COMPARE_X
                            ;COMPARE_N:      lda     #-1;
                            
                            ;COMPARE_X:      sta     <7                      ; Save the result
                            ;                tdc
                            ;                clc
                            ;                adc     #6
                            ;                tcd
                            ;                CONTINUE                        ; Done
                                    .ENDIF
00CFC2  3F                :                 XPPC    R2
                                            
                            ; COUNT ( c-addr1 -- c-addr2 u )
                            ;
                            ; Return the character string specification for the counted string stored at
                            ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
                            ; the contents of the character at c-addr1, which is the length in characters
                            ; of the string at c-addr2.
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   DUP CHAR+ SWAP C@
                            
                                            WORD    "COUNT",NORMAL
        0000CFC3          = THIS            .SET    $
00CFC3  B5CF              +                 .WORD   LAST
00CFC5  00                +                 .BYTE   NORMAL
00CFC6  05                +                 .BYTE   STRLEN("COUNT")
00CFC7  434F554E54        +                 .BYTE   "COUNT"
        0000CFC3          = LAST            .SET    THIS
                            COUNT:          FORTH
00CFCC  6ED0              +                 .WORD   DO_COLON-1
00CFCE  5DC3              :                 .WORD   DUP
00CFD0  ACC2              :                 .WORD   CHAR_PLUS
00CFD2  E4C3              :                 .WORD   SWAP
00CFD4  3AC2              :                 .WORD   C_FETCH
00CFD6  86CB              :                 .WORD   EXIT
                            
                            ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
                            ;
                            ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
                            ; u2. If flag is true, a match was found at c-addr3 with u3 characters
                            ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
                            ; is u1.
                            
                                            WORD    "SEARCH",NORMAL
        0000CFD8          = THIS            .SET    $

Portable National Semiconductor SC/MP Assembler [16.09]

00CFD8  C3CF              +                 .WORD   LAST
00CFDA  00                +                 .BYTE   NORMAL
00CFDB  06                +                 .BYTE   STRLEN("SEARCH")
00CFDC  534541524348      +                 .BYTE   "SEARCH"
        0000CFD8          = LAST            .SET    THIS
                            SEARCH:         FORTH
00CFE2  6ED0              +                 .WORD   DO_COLON-1
                            ; TODO
00CFE4  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; Compiling Words
                            ;-------------------------------------------------------------------------------
                            
                            ; ( ( -- )
                            ;
                            ; Parse ccc delimited by ) (right parenthesis). ( is an immediate word.
                            ;
                            ; The number of characters in ccc may be zero to the number of characters in the
                            ; parse area.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
                            
                                            WORD    "(",IMMEDIATE
        0000CFE6          = THIS            .SET    $
00CFE6  D8CF              +                 .WORD   LAST
00CFE8  80                +                 .BYTE   IMMEDIATE
00CFE9  01                +                 .BYTE   STRLEN("(")
00CFEA  28                +                 .BYTE   "("
        0000CFE6          = LAST            .SET    THIS
                            LEFT_PAREN:     FORTH
00CFEB  6ED0              +                 .WORD   DO_COLON-1
00CFED  74D22900          :                 .WORD   DO_LITERAL,')'
00CFF1  02CF              :                 .WORD   WORD
00CFF3  4FC3              :                 .WORD   DROP
00CFF5  86CB              :                 .WORD   EXIT
                            
                            ; .( ( “ccc<paren>” -- )
                            ;
                            ; Parse and display ccc delimited by ) (right parenthesis). .( is an immediate
                            ; word.
                            
                                            WORD    ".(",IMMEDIATE
        0000CFF7          = THIS            .SET    $
00CFF7  E6CF              +                 .WORD   LAST
00CFF9  80                +                 .BYTE   IMMEDIATE
00CFFA  02                +                 .BYTE   STRLEN(".(")
00CFFB  2E28              +                 .BYTE   ".("
        0000CFF7          = LAST            .SET    THIS
                            DOT_PAREN:      FORTH
00CFFD  6ED0              +                 .WORD   DO_COLON-1
00CFFF  74D22900          :                 .WORD   DO_LITERAL,')'

Portable National Semiconductor SC/MP Assembler [16.09]

00D003  02CF              :                 .WORD   WORD
00D005  CCCF              :                 .WORD   COUNT
00D007  BCD4              :                 .WORD   TYPE
00D009  86CB              :                 .WORD   EXIT
                            
                            ; ." ( “ccc<quote>” -- )
                            ;
                            ; Parse ccc delimited by " (double-quote). Append the run-time semantics given
                            ; below to the current definition.
                            
                                            WORD    ".\"",IMMEDIATE
        0000D00B          = THIS            .SET    $
00D00B  F7CF              +                 .WORD   LAST
00D00D  80                +                 .BYTE   IMMEDIATE
00D00E  02                +                 .BYTE   STRLEN(".\"")
00D00F  2E22              +                 .BYTE   ".\""
        0000D00B          = LAST            .SET    THIS
                            DOT_QUOTE:      FORTH
00D011  6ED0              +                 .WORD   DO_COLON-1
00D013  09D3              :                 .WORD   S_QUOTE
00D015  74D2BCD4          :                 .WORD   DO_LITERAL,TYPE
00D019  8CC1              :                 .WORD   COMMA
00D01B  86CB              :                 .WORD   EXIT
                            
                            ; +LOOP ( -- )
                            
                                            WORD    "+LOOP",IMMEDIATE
        0000D01D          = THIS            .SET    $
00D01D  0BD0              +                 .WORD   LAST
00D01F  80                +                 .BYTE   IMMEDIATE
00D020  05                +                 .BYTE   STRLEN("+LOOP")
00D021  2B4C4F4F50        +                 .BYTE   "+LOOP"
        0000D01D          = LAST            .SET    THIS
                            PLUS_LOOP:      FORTH
00D026  6ED0              +                 .WORD   DO_COLON-1
00D028  74D23ED0          :                 .WORD   DO_LITERAL,DO_PLUS_LOOP
00D02C  8CC1              :                 .WORD   COMMA
00D02E  8CC1              :                 .WORD   COMMA
00D030  1FC3              :                 .WORD   QUERY_DUP
00D032  10D23CD0          :                 .WORD   QUERY_BRANCH,PLUS_LOOP_1
00D036  5FC2              :                 .WORD   HERE
00D038  E4C3              :                 .WORD   SWAP
00D03A  32C1              :                 .WORD   STORE
00D03C  86CB              : PLUS_LOOP_1:    .WORD   EXIT
                            
                            DO_PLUS_LOOP:   NATIVE
00D03E  3FD0              +                 .WORD   $+1
                                    .IF 0
                                            ldx     <1                      ; Fetch increment
                                            tdc                             ; And drop
                                            inc     a
                                            inc     a
                                            tcd
                                            clc                             ; Add to loop counter

Portable National Semiconductor SC/MP Assembler [16.09]

                                            txa
                                            adc     1,s
                                            sta     1,s
                                            cmp     3,s                     ; Reached limit?
                                            bcs     DO_PLOOP_END            ; Yes
                                            lda     !0,y                    ; No, branch back to start
                                            tay
                                            CONTINUE                        ; Done
                            
                          : DO_PLOOP_END:   iny                             ; Skip over address
                                            iny
                                            pla                             ; Drop loop variables
                                            pla
                                            CONTINUE                        ; Done
                                    .ENDIF
00D040  3F                :                 XPPC    R2
                            
                            ; ' ( -- xt )
                            ;
                            ; Skip leading space delimiters. Parse name delimited by a space. Find name and
                            ; return xt, the execution token for name. An ambiguous condition exists if name
                            ; is not found.
                            ;
                            ; In this implementation it is defined as:
                            ;
                            ;   BL WORD FIND 0= IF ." ?" ABORT THEN
                            
                                            WORD    "'",NORMAL
        0000D041          = THIS            .SET    $
00D041  1DD0              +                 .WORD   LAST
00D043  00                +                 .BYTE   NORMAL
00D044  01                +                 .BYTE   STRLEN("'")
00D045  27                +                 .BYTE   "'"
        0000D041          = LAST            .SET    THIS
                            TICK:           FORTH
00D046  6ED0              +                 .WORD   DO_COLON-1
00D048  E6C0              :                 .WORD   BL
00D04A  02CF              :                 .WORD   WORD
00D04C  EFCD              :                 .WORD   FIND
00D04E  A5C9              :                 .WORD   ZERO_EQUAL
00D050  10D25AD0          :                 .WORD   QUERY_BRANCH,TICK_1
00D054  21D3              :                 .WORD   DO_S_QUOTE
00D056  013F              :                 .BYTE   1,"?"
00D058  15CB              :                 .WORD   ABORT
00D05A  86CB              : TICK_1:         .WORD   EXIT
                            
                            ; : ( -- )
                            
                                            WORD    ":",NORMAL
        0000D05C          = THIS            .SET    $
00D05C  41D0              +                 .WORD   LAST
00D05E  00                +                 .BYTE   NORMAL
00D05F  01                +                 .BYTE   STRLEN(":")
00D060  3A                +                 .BYTE   ":"

Portable National Semiconductor SC/MP Assembler [16.09]

        0000D05C          = LAST            .SET    THIS
                            COLON:          FORTH
00D061  6ED0              +                 .WORD   DO_COLON-1
00D063  38CB              :                 .WORD   CREATE
00D065  74D26FD0          :                 .WORD   DO_LITERAL,DO_COLON
00D069  26CB              :                 .WORD   BUILD
00D06B  22D4              :                 .WORD   RIGHT_BRACKET
00D06D  86CB              :                 .WORD   EXIT
                            
                            DO_COLON:
00D06F  B904              :                 DLD     RP+0(MA)        ; Create a cell on the return stack
00D071  B904              :                 DLD     RP+0(MA)        ; .. and load the pointer
00D073  33                :                 XPAL    R2
00D074  C105              :                 LD      RP+1(MA)
00D076  37                :                 XPAH    R2
00D077  C100              :                 LD      IP+0(MA)        ; Push the old IP
00D079  CB00              :                 ST      0(R2)
00D07B  C101              :                 LD      IP+1(MA)
00D07D  CB01              :                 ST      1(R2)
00D07F  02                :                 CCL                     ; Calculate new IP from WA
00D080  32                :                 XPAL    R1
00D081  F402              :                 ADI     2
00D083  C900              :                 ST      IP+0(MA)
00D085  36                :                 XPAH    R1
00D086  F400              :                 ADI     0
00D088  C901              :                 ST      IP+1(MA)
                            
                            NEXT:
00D08A  C100              :                 LD      IP+0(MA)        ; Load the instruction pointer
00D08C  33                :                 XPAL    R2
00D08D  C101              :                 LD      IP+1(MA)
00D08F  37                :                 XPAH    R2
                            
00D090  A900              :                 ILD     IP+0(MA)        ; Bump the IP
00D092  9C02              :                 JNZ     .SKIPL
00D094  A901              :                 ILD     IP+1(MA)
                            .SKIPL
00D096  A900              :                 ILD     IP+0(MA)
00D098  9C02              :                 JNZ     .SKIPH
00D09A  A901              :                 ILD     IP+1(MA)
                            .SKIPH
                            
00D09C  C300              :                 LD      0(R2)           ; Fetch the next word address
00D09E  32                :                 XPAL    R1
00D09F  C301              :                 LD      1(R2)
00D0A1  36                :                 XPAH    R1
                            
00D0A2  C200              :                 LD      0(R1)           ; Fetch the code address
00D0A4  33                :                 XPAL    R2
00D0A5  C201              :                 LD      1(R1)
00D0A7  37                :                 XPAH    R2
                            
00D0A8  3F                :                 XPPC    R2              ; Execute the word
00D0A9  90DF              :                 JMP     NEXT            ; And repeat

Portable National Semiconductor SC/MP Assembler [16.09]

                            
                            ; :NONAME ( -- xt )
                            
                                            WORD    ":NONAME",NORMAL
        0000D0AB          = THIS            .SET    $
00D0AB  5CD0              +                 .WORD   LAST
00D0AD  00                +                 .BYTE   NORMAL
00D0AE  07                +                 .BYTE   STRLEN(":NONAME")
00D0AF  3A4E4F4E414D45    +                 .BYTE   ":NONAME"
        0000D0AB          = LAST            .SET    THIS
                            NONAME:         FORTH
00D0B6  6ED0              +                 .WORD   DO_COLON-1
00D0B8  5FC2              :                 .WORD   HERE
00D0BA  74D26FD0          :                 .WORD   DO_LITERAL,DO_COLON
00D0BE  26CB              :                 .WORD   BUILD
00D0C0  22D4              :                 .WORD   RIGHT_BRACKET
00D0C2  86CB              :                 .WORD   EXIT
                            
                            ; ; ( -- )
                            
                                            WORD    ";",IMMEDIATE
        0000D0C4          = THIS            .SET    $
00D0C4  ABD0              +                 .WORD   LAST
00D0C6  80                +                 .BYTE   IMMEDIATE
00D0C7  01                +                 .BYTE   STRLEN(";")
00D0C8  3B                +                 .BYTE   ";"
        0000D0C4          = LAST            .SET    THIS
                            SEMICOLON:      FORTH
00D0C9  6ED0              +                 .WORD   DO_COLON-1
00D0CB  74D286CB          :                 .WORD   DO_LITERAL,EXIT
00D0CF  8CC1              :                 .WORD   COMMA
00D0D1  D5D3              :                 .WORD   LEFT_BRACKET
00D0D3  86CB              :                 .WORD   EXIT
                            
                            ; ?DO ( -- jump orig )
                            
                                            WORD    "?DO",IMMEDIATE
        0000D0D5          = THIS            .SET    $
00D0D5  C4D0              +                 .WORD   LAST
00D0D7  80                +                 .BYTE   IMMEDIATE
00D0D8  03                +                 .BYTE   STRLEN("?DO")
00D0D9  3F444F            +                 .BYTE   "?DO"
        0000D0D5          = LAST            .SET    THIS
                            QUERY_DO:       FORTH
00D0DC  6ED0              +                 .WORD   DO_COLON-1
00D0DE  74D2EED0          :                 .WORD   DO_LITERAL,QUERY_DO_DO
00D0E2  8CC1              :                 .WORD   COMMA
00D0E4  5FC2              :                 .WORD   HERE
00D0E6  DCC0              :                 .WORD   ZERO
00D0E8  8CC1              :                 .WORD   COMMA
00D0EA  5FC2              :                 .WORD   HERE
00D0EC  86CB              :                 .WORD   EXIT
                            
                            QUERY_DO_DO:    NATIVE

Portable National Semiconductor SC/MP Assembler [16.09]

00D0EE  EFD0              +                 .WORD   $+1
                                    .IF 0
                                            lda     <1                      ; Are the start and limit
                                            eor     <3                      ; .. the same?
                                            beq     QUERY_DO_DO_1
                                            iny                             ; No, Skip over jump address
                                            iny
                          -                 jmp     DO_DO                   ; And start a normal loop
                            
                          : QUERY_DO_DO_1:  tdc                             ; Drop the loop parameters
                                            inc     a
                                            inc     a
                                            inc     a
                                            inc     a
                                            tcd
                          -                 jmp     BRANCH                  ; And skip over loop
                                    .ENDIF
00D0F0  3F                :                 XPPC    R2
                            
                            ; 2CONSTANT ( x “<spaces>name” -- )
                            ;
                            ; Skip leading space delimiters. Parse name delimited by a space. Create a
                            ; definition for name with the execution semantics defined below.
                            
                                            WORD    "2CONSTANT",NORMAL
        0000D0F1          = THIS            .SET    $
00D0F1  D5D0              +                 .WORD   LAST
00D0F3  00                +                 .BYTE   NORMAL
00D0F4  09                +                 .BYTE   STRLEN("2CONSTANT")
00D0F5  32434F4E5354414E> +                 .BYTE   "2CONSTANT"
        0000D0F1          = LAST            .SET    THIS
                            TWO_CONSTANT:   FORTH
00D0FE  6ED0              +                 .WORD   DO_COLON-1
00D100  38CB              :                 .WORD   CREATE
00D102  74D20ED1          :                 .WORD   DO_LITERAL,DO_TWO_CONSTANT
00D106  26CB              :                 .WORD   BUILD
00D108  8CC1              :                 .WORD   COMMA
00D10A  8CC1              :                 .WORD   COMMA
00D10C  86CB              :                 .WORD   EXIT
                            
                            DO_TWO_CONSTANT: NATIVE
00D10E  0FD1              +                 .WORD   $+1
                                    .IF 0
                                            plx                             ; Get return address
                                            tdc                             ; Create space on stack
                                            dec     a
                                            dec     a
                                            dec     a
                                            dec     a
                                            tcd
                                            lda     !1,x                    ; Transfer the value
                                            sta     <1
                                            lda     !3,x
                                            sta     <3

Portable National Semiconductor SC/MP Assembler [16.09]

                                            CONTINUE                        ; Done
                                    .ENDIF
00D110  3F                :                 XPPC    R2
                            
                            ; 2LITERAL
                            
                                            WORD    "2LITERAL",IMMEDIATE
        0000D111          = THIS            .SET    $
00D111  F1D0              +                 .WORD   LAST
00D113  80                +                 .BYTE   IMMEDIATE
00D114  08                +                 .BYTE   STRLEN("2LITERAL")
00D115  324C49544552414C  +                 .BYTE   "2LITERAL"
        0000D111          = LAST            .SET    THIS
                            TWO_LITERAL:    FORTH
00D11D  6ED0              +                 .WORD   DO_COLON-1
00D11F  74D22BD1          :                 .WORD   DO_LITERAL,DO_TWO_LITERAL
00D123  8CC1              :                 .WORD   COMMA
00D125  8CC1              :                 .WORD   COMMA
00D127  8CC1              :                 .WORD   COMMA
00D129  86CB              :                 .WORD   EXIT
                            
                            DO_TWO_LITERAL: NATIVE
00D12B  2CD1              +                 .WORD   $+1
                                    .IF     0
                                            tdc                             ; Make room on stack
                                            dec     a
                                            dec     a
                                            dec     a
                                            dec     a
                                            tcd
                                            lda     !0,y                    ; Fetch constant from IP
                                            sta     <1
                                            lda     !2,y
                                            sta     <3
                                            iny                             ; Bump IP
                                            iny
                                            iny
                                            iny
                                            CONTINUE                        ; Done
                                    .ENDIF
00D12D  3F                :                 XPPC    R2
                            
                            ; 2VARIABLE
                            
                                            WORD    "2VARIABLE",IMMEDIATE
        0000D12E          = THIS            .SET    $
00D12E  11D1              +                 .WORD   LAST
00D130  80                +                 .BYTE   IMMEDIATE
00D131  09                +                 .BYTE   STRLEN("2VARIABLE")
00D132  325641524941424C> +                 .BYTE   "2VARIABLE"
        0000D12E          = LAST            .SET    THIS
                            TWO_VARIABLE:   FORTH
00D13B  6ED0              +                 .WORD   DO_COLON-1
00D13D  38CB              :                 .WORD   CREATE

Portable National Semiconductor SC/MP Assembler [16.09]

00D13F  74D28FD3          :                 .WORD   DO_LITERAL,DO_VARIABLE
00D143  26CB              :                 .WORD   BUILD
00D145  74D20200          :                 .WORD   DO_LITERAL,2
00D149  9DC2              :                 .WORD   CELLS
00D14B  EFC1              :                 .WORD   ALLOT
00D14D  86CB              :                 .WORD   EXIT
                            
                            ; ABORT" ( -- )
                            
                                            WORD    "ABORT\"",IMMEDIATE
        0000D14F          = THIS            .SET    $
00D14F  2ED1              +                 .WORD   LAST
00D151  80                +                 .BYTE   IMMEDIATE
00D152  06                +                 .BYTE   STRLEN("ABORT\"")
00D153  41424F525422      +                 .BYTE   "ABORT\""
        0000D14F          = LAST            .SET    THIS
                            ABORT_QUOTE:    FORTH
00D159  6ED0              +                 .WORD   DO_COLON-1
00D15B  09D3              :                 .WORD   S_QUOTE
00D15D  74D2FCCA          :                 .WORD   DO_LITERAL,QUERY_ABORT
00D161  8CC1              :                 .WORD   COMMA
00D163  86CB              :                 .WORD   EXIT
                            
                            ; AGAIN ( orig -- )
                            
                                            WORD    "AGAIN",IMMEDIATE
        0000D165          = THIS            .SET    $
00D165  4FD1              +                 .WORD   LAST
00D167  80                +                 .BYTE   IMMEDIATE
00D168  05                +                 .BYTE   STRLEN("AGAIN")
00D169  414741494E        +                 .BYTE   "AGAIN"
        0000D165          = LAST            .SET    THIS
                            AGAIN:          FORTH
00D16E  6ED0              +                 .WORD   DO_COLON-1
00D170  74D2EFD1          :                 .WORD   DO_LITERAL,BRANCH
00D174  8CC1              :                 .WORD   COMMA
00D176  8CC1              :                 .WORD   COMMA
00D178  86CB              :                 .WORD   EXIT
                            
                            ; BEGIN ( -- orig )
                            
                                            WORD    "BEGIN",IMMEDIATE
        0000D17A          = THIS            .SET    $
00D17A  65D1              +                 .WORD   LAST
00D17C  80                +                 .BYTE   IMMEDIATE
00D17D  05                +                 .BYTE   STRLEN("BEGIN")
00D17E  424547494E        +                 .BYTE   "BEGIN"
        0000D17A          = LAST            .SET    THIS
                            BEGIN:          FORTH
00D183  6ED0              +                 .WORD   DO_COLON-1
00D185  5FC2              :                 .WORD   HERE
00D187  86CB              :                 .WORD   EXIT
                            
                            ; CHAR ( -- char )

Portable National Semiconductor SC/MP Assembler [16.09]

                            ;
                            ;   BL WORD 1+ C@
                            
                                            WORD    "CHAR",NORMAL
        0000D189          = THIS            .SET    $
00D189  7AD1              +                 .WORD   LAST
00D18B  00                +                 .BYTE   NORMAL
00D18C  04                +                 .BYTE   STRLEN("CHAR")
00D18D  43484152          +                 .BYTE   "CHAR"
        0000D189          = LAST            .SET    THIS
                            CHAR:           FORTH
00D191  6ED0              +                 .WORD   DO_COLON-1
00D193  E6C0              :                 .WORD   BL
00D195  02CF              :                 .WORD   WORD
00D197  B0C5              :                 .WORD   ONE_PLUS
00D199  3AC2              :                 .WORD   C_FETCH
00D19B  86CB              :                 .WORD   EXIT
                            
                            ; CONSTANT ( x “<spaces>name” -- )
                            ;
                            ; Skip leading space delimiters. Parse name delimited by a space. Create a
                            ; definition for name with the execution semantics defined below.
                            
                                            WORD    "CONSTANT",NORMAL
        0000D19D          = THIS            .SET    $
00D19D  89D1              +                 .WORD   LAST
00D19F  00                +                 .BYTE   NORMAL
00D1A0  08                +                 .BYTE   STRLEN("CONSTANT")
00D1A1  434F4E5354414E54  +                 .BYTE   "CONSTANT"
        0000D19D          = LAST            .SET    THIS
                            CONSTANT:       FORTH
00D1A9  6ED0              +                 .WORD   DO_COLON-1
00D1AB  38CB              :                 .WORD   CREATE
00D1AD  74D2B7D1          :                 .WORD   DO_LITERAL,DO_CONSTANT
00D1B1  26CB              :                 .WORD   BUILD
00D1B3  8CC1              :                 .WORD   COMMA
00D1B5  86CB              :                 .WORD   EXIT
                            
                            DO_CONSTANT:    NATIVE
00D1B7  B8D1              +                 .WORD   $+1
                            
00D1B9  3F                :                 XPPC    R2
                            
                            ; DO ( -- 0 orig )
                            
                                            WORD    "DO",IMMEDIATE
        0000D1BA          = THIS            .SET    $
00D1BA  9DD1              +                 .WORD   LAST
00D1BC  80                +                 .BYTE   IMMEDIATE
00D1BD  02                +                 .BYTE   STRLEN("DO")
00D1BE  444F              +                 .BYTE   "DO"
        0000D1BA          = LAST            .SET    THIS
                            DO:             FORTH
00D1C0  6ED0              +                 .WORD   DO_COLON-1

Portable National Semiconductor SC/MP Assembler [16.09]

00D1C2  74D2CED1          :                 .WORD   DO_LITERAL,DO_DO
00D1C6  8CC1              :                 .WORD   COMMA
00D1C8  DCC0              :                 .WORD   ZERO
00D1CA  5FC2              :                 .WORD   HERE
00D1CC  86CB              :                 .WORD   EXIT
                            
                            DO_DO:          NATIVE
00D1CE  CFD1              +                 .WORD   $+1
                                    .IF     0
                                            lda     <3
                                            pha
                                            lda     <1
                                            pha
                                            tdc
                                            inc     a
                                            inc     a
                                            inc     a
                                            inc     a
                                            tcd
                                            CONTINUE
                                    .ENDIF
00D1D0  3F                :                 XPPC    R2
                            
                            ; ELSE ( jump -- jump' )
                            
                                            WORD    "ELSE",IMMEDIATE
        0000D1D1          = THIS            .SET    $
00D1D1  BAD1              +                 .WORD   LAST
00D1D3  80                +                 .BYTE   IMMEDIATE
00D1D4  04                +                 .BYTE   STRLEN("ELSE")
00D1D5  454C5345          +                 .BYTE   "ELSE"
        0000D1D1          = LAST            .SET    THIS
                            ELSE:           FORTH
00D1D9  6ED0              +                 .WORD   DO_COLON-1
00D1DB  74D2EFD1          :                 .WORD   DO_LITERAL,BRANCH
00D1DF  8CC1              :                 .WORD   COMMA
00D1E1  5FC2              :                 .WORD   HERE
00D1E3  DCC0              :                 .WORD   ZERO
00D1E5  8CC1              :                 .WORD   COMMA
00D1E7  5FC2              :                 .WORD   HERE
00D1E9  E4C3              :                 .WORD   SWAP
00D1EB  32C1              :                 .WORD   STORE
00D1ED  86CB              :                 .WORD   EXIT
                            
                            BRANCH:         NATIVE
00D1EF  F0D1              +                 .WORD   $+1
00D1F1  C202              :                 LD      2(R1)           ; Fetch the new IP value
00D1F3  C900              :                 ST      IP+0(MA)
00D1F5  C203              :                 LD      3(R1)
00D1F7  C901              :                 ST      IP+1(MA)
00D1F9  3F                :                 XPPC    R2              ; And continue
                            
                            ; IF ( -- jump )
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                                            WORD    "IF",IMMEDIATE
        0000D1FA          = THIS            .SET    $
00D1FA  D1D1              +                 .WORD   LAST
00D1FC  80                +                 .BYTE   IMMEDIATE
00D1FD  02                +                 .BYTE   STRLEN("IF")
00D1FE  4946              +                 .BYTE   "IF"
        0000D1FA          = LAST            .SET    THIS
                            IF:             FORTH
00D200  6ED0              +                 .WORD   DO_COLON-1
00D202  74D210D2          :                 .WORD   DO_LITERAL,QUERY_BRANCH
00D206  8CC1              :                 .WORD   COMMA
00D208  5FC2              :                 .WORD   HERE
00D20A  DCC0              :                 .WORD   ZERO
00D20C  8CC1              :                 .WORD   COMMA
00D20E  86CB              :                 .WORD   EXIT
                            
                            QUERY_BRANCH:   NATIVE
00D210  11D2              +                 .WORD   $+1
00D212  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00D214  33                :                 XPAL    R2
00D215  C107              :                 LD      SP+1(MA)
00D217  37                :                 XPAH    R2
00D218  C300              :                 LD      0(R2)           ; Test the top cell value
00D21A  DB01              :                 OR      1(R2)
00D21C  01                :                 XAE                     ; .. and save the result
00D21D  A906              :                 ILD     SP+0(MA)        ; Drop the top cell
00D21F  A906              :                 ILD     SP+0(MA)
00D221  C489              :                 LDI     LO(NEXT-1)      ; Restore the NEXT pointer
00D223  33                :                 XPAL    R2
00D224  C4D0              :                 LDI     HI(NEXT-1)
00D226  37                :                 XPAH    R2
00D227  40                :                 LDE
00D228  9C09              :                 JNZ     .CONTINUE
                            
00D22A  C202              :                 LD      2(R1)           ; Fetch the new IP value
00D22C  C900              :                 ST      IP+0(MA)
00D22E  C203              :                 LD      3(R1)
00D230  C901              :                 ST      IP+1(MA)
00D232  3F                :                 XPPC    R2              ; And continue
                            
00D233  A900              : .CONTINUE       ILD     IP+0(MA)        ; Increment IP over link
00D235  9C02              :                 JNZ     .SKIP1
00D237  A901              :                 ILD     IP+1(MA)
00D239  A900              : .SKIP1          ILD     IP+0(MA)
00D23B  9C02              :                 JNZ     .SKIP2
00D23D  A901              :                 ILD     IP+1(MA)
00D23F  3F                : .SKIP2          XPPC    R2              ; And continue
                            
                            ; IMMEDIATE ( -- )
                            
                                            WORD    "IMMEDIATE",IMMEDIATE
        0000D240          = THIS            .SET    $
00D240  FAD1              +                 .WORD   LAST
00D242  80                +                 .BYTE   IMMEDIATE

Portable National Semiconductor SC/MP Assembler [16.09]

00D243  09                +                 .BYTE   STRLEN("IMMEDIATE")
00D244  494D4D4544494154> +                 .BYTE   "IMMEDIATE"
        0000D240          = LAST            .SET    THIS
                            IMMED:          FORTH
00D24D  6ED0              +                 .WORD   DO_COLON-1
00D24F  74D28000          :                 .WORD   DO_LITERAL,IMMEDIATE
00D253  A8C0              :                 .WORD   LATEST
00D255  C9C1              :                 .WORD   FETCH
00D257  C0C5              :                 .WORD   ONE_MINUS
00D259  FDC1              :                 .WORD   C_STORE
00D25B  86CB              :                 .WORD   EXIT
                            
                            ; LITERAL ( x -- )
                            ;
                            ; Append the run-time semantics given below to the current definition.
                            
                                            WORD    "LITERAL",IMMEDIATE
        0000D25D          = THIS            .SET    $
00D25D  40D2              +                 .WORD   LAST
00D25F  80                +                 .BYTE   IMMEDIATE
00D260  07                +                 .BYTE   STRLEN("LITERAL")
00D261  4C49544552414C    +                 .BYTE   "LITERAL"
        0000D25D          = LAST            .SET    THIS
                            LITERAL:        FORTH
00D268  6ED0              +                 .WORD   DO_COLON-1
00D26A  74D274D2          :                 .WORD   DO_LITERAL,DO_LITERAL
00D26E  8CC1              :                 .WORD   COMMA
00D270  8CC1              :                 .WORD   COMMA
00D272  86CB              :                 .WORD   EXIT
                            
                            DO_LITERAL:     NATIVE
00D274  75D2              +                 .WORD   $+1
                            
00D276  3F                :                 XPPC    R2              ; And continue
                            
                            
                            ; LOOP ( jump orig -- )
                            
                                            WORD    "LOOP",IMMEDIATE
        0000D277          = THIS            .SET    $
00D277  5DD2              +                 .WORD   LAST
00D279  80                +                 .BYTE   IMMEDIATE
00D27A  04                +                 .BYTE   STRLEN("LOOP")
00D27B  4C4F4F50          +                 .BYTE   "LOOP"
        0000D277          = LAST            .SET    THIS
                            LOOP:           FORTH
00D27F  6ED0              +                 .WORD   DO_COLON-1
00D281  74D297D2          :                 .WORD   DO_LITERAL,DO_LOOP
00D285  8CC1              :                 .WORD   COMMA
00D287  8CC1              :                 .WORD   COMMA
00D289  1FC3              :                 .WORD   QUERY_DUP
00D28B  10D295D2          :                 .WORD   QUERY_BRANCH,LOOP_1
00D28F  5FC2              :                 .WORD   HERE
00D291  E4C3              :                 .WORD   SWAP

Portable National Semiconductor SC/MP Assembler [16.09]

00D293  32C1              :                 .WORD   STORE
00D295  86CB              : LOOP_1:         .WORD   EXIT
                            
                            ; (LOOP)
                            
                            DO_LOOP:        NATIVE
00D297  98D2              +                 .WORD   $+1
                                    .IF     0
                                            lda     1,s                     ; Add one to loop counter
                                            inc     a
                                            sta     1,s
                                            cmp     3,s                     ; Reached limit?
                                            bcs     DO_LOOP_END             ; Yes
                                            lda     !0,y                    ; No, branch back to start
                                            tay
                                            CONTINUE                        ; Done
                            
                          : DO_LOOP_END:    iny                             ; Skip over address
                                            iny
                                            pla                             ; Drop loop variables
                                            pla
                                            CONTINUE                        ; Done
                                    .ENDIF
00D299  3F                :         XPPC    R2
                            
                            ; POSTPONE
                            
                            ;   BL WORD FIND
                            ;   DUP 0= ABORT" ?"
                            ;   0< IF   -- xt       non immed: add code to current
                            ;                       def'n to compile xt later.
                            ;       ['] LIT ,XT  ,  add "LIT,xt,COMMAXT"
                            ;       ['] ,XT ,XT     to current definition
                            ;   ELSE  ,XT      immed: compile into cur. def'n
                            ;   THEN ; IMMEDIATE
                            
                                            WORD    "POSTPONE",IMMEDIATE
        0000D29A          = THIS            .SET    $
00D29A  77D2              +                 .WORD   LAST
00D29C  80                +                 .BYTE   IMMEDIATE
00D29D  08                +                 .BYTE   STRLEN("POSTPONE")
00D29E  504F5354504F4E45  +                 .BYTE   "POSTPONE"
        0000D29A          = LAST            .SET    THIS
                            POSTPONE:       FORTH
00D2A6  6ED0              +                 .WORD   DO_COLON-1
00D2A8  E6C0              :                 .WORD   BL
00D2AA  02CF              :                 .WORD   WORD
00D2AC  EFCD              :                 .WORD   FIND
00D2AE  5DC3              :                 .WORD   DUP
00D2B0  A5C9              :                 .WORD   ZERO_EQUAL
00D2B2  21D3              :                 .WORD   DO_S_QUOTE
00D2B4  013F              :                 .BYTE   1,"?"
00D2B6  FCCA              :                 .WORD   QUERY_ABORT
00D2B8  6BC9              :                 .WORD   ZERO_LESS

Portable National Semiconductor SC/MP Assembler [16.09]

00D2BA  10D2CAD2          :                 .WORD   QUERY_BRANCH,POSTPONE_1
00D2BE  74D274D2          :                 .WORD   DO_LITERAL,DO_LITERAL
00D2C2  8CC1              :                 .WORD   COMMA
00D2C4  8CC1              :                 .WORD   COMMA
00D2C6  EFD1CCD2          :                 .WORD   BRANCH,POSTPONE_2
00D2CA  8CC1              : POSTPONE_1:     .WORD   COMMA
00D2CC  86CB              : POSTPONE_2:     .WORD   EXIT
                            
                            ; RECURSE ( -- )
                            
                                            WORD    "RECURSE",IMMEDIATE
        0000D2CE          = THIS            .SET    $
00D2CE  9AD2              +                 .WORD   LAST
00D2D0  80                +                 .BYTE   IMMEDIATE
00D2D1  07                +                 .BYTE   STRLEN("RECURSE")
00D2D2  52454355525345    +                 .BYTE   "RECURSE"
        0000D2CE          = LAST            .SET    THIS
                            RECURSE:        FORTH
00D2D9  6ED0              +                 .WORD   DO_COLON-1
00D2DB  A8C0              :                 .WORD   LATEST
00D2DD  C9C1              :                 .WORD   FETCH
00D2DF  35CE              :                 .WORD   NFA_TO_CFA
00D2E1  8CC1              :                 .WORD   COMMA
00D2E3  86CB              :                 .WORD   EXIT
                            
                            ; REPEAT ( orig jump -- )
                            
                                            WORD    "REPEAT",IMMEDIATE
        0000D2E5          = THIS            .SET    $
00D2E5  CED2              +                 .WORD   LAST
00D2E7  80                +                 .BYTE   IMMEDIATE
00D2E8  06                +                 .BYTE   STRLEN("REPEAT")
00D2E9  524550454154      +                 .BYTE   "REPEAT"
        0000D2E5          = LAST            .SET    THIS
                            REPEAT:         FORTH
00D2EF  6ED0              +                 .WORD   DO_COLON-1
00D2F1  E4C3              :                 .WORD   SWAP
00D2F3  74D2EFD1          :                 .WORD   DO_LITERAL,BRANCH
00D2F7  8CC1              :                 .WORD   COMMA
00D2F9  8CC1              :                 .WORD   COMMA
00D2FB  5FC2              :                 .WORD   HERE
00D2FD  E4C3              :                 .WORD   SWAP
00D2FF  32C1              :                 .WORD   STORE
00D301  86CB              :                 .WORD   EXIT
                            
                            ; S"
                            
                                            WORD    "S\"",IMMEDIATE
        0000D303          = THIS            .SET    $
00D303  E5D2              +                 .WORD   LAST
00D305  80                +                 .BYTE   IMMEDIATE
00D306  02                +                 .BYTE   STRLEN("S\"")
00D307  5322              +                 .BYTE   "S\""
        0000D303          = LAST            .SET    THIS

Portable National Semiconductor SC/MP Assembler [16.09]

                            S_QUOTE:        FORTH
00D309  6ED0              +                 .WORD   DO_COLON-1
00D30B  74D221D3          :                 .WORD   DO_LITERAL,DO_S_QUOTE
00D30F  8CC1              :                 .WORD   COMMA
00D311  74D22200          :                 .WORD   DO_LITERAL,'"'
00D315  02CF              :                 .WORD   WORD
00D317  3AC2              :                 .WORD   C_FETCH
00D319  B0C5              :                 .WORD   ONE_PLUS
00D31B  7EC2              :                 .WORD   ALIGNED
00D31D  EFC1              :                 .WORD   ALLOT
00D31F  86CB              :                 .WORD   EXIT
                            
                            ; (S") ( -- c-addr u )
                            
                            DO_S_QUOTE:
                                            FORTH
00D321  6ED0              +                 .WORD   DO_COLON-1
00D323  C3C4              :                 .WORD   R_FROM
00D325  CCCF              :                 .WORD   COUNT
00D327  E9C2              :                 .WORD   TWO_DUP
00D329  48C5              :                 .WORD   PLUS
00D32B  7EC2              :                 .WORD   ALIGNED
00D32D  52C4              :                 .WORD   TO_R
00D32F  86CB              :                 .WORD   EXIT
                            
                            ; THEN ( orig -- )
                            
                                            WORD    "THEN",IMMEDIATE
        0000D331          = THIS            .SET    $
00D331  03D3              +                 .WORD   LAST
00D333  80                +                 .BYTE   IMMEDIATE
00D334  04                +                 .BYTE   STRLEN("THEN")
00D335  5448454E          +                 .BYTE   "THEN"
        0000D331          = LAST            .SET    THIS
                            THEN:           FORTH
00D339  6ED0              +                 .WORD   DO_COLON-1
00D33B  5FC2              :                 .WORD   HERE
00D33D  E4C3              :                 .WORD   SWAP
00D33F  32C1              :                 .WORD   STORE
00D341  86CB              :                 .WORD   EXIT
                            
                            ; UNTIL ( orig -- )
                            
                                            WORD    "UNTIL",IMMEDIATE
        0000D343          = THIS            .SET    $
00D343  31D3              +                 .WORD   LAST
00D345  80                +                 .BYTE   IMMEDIATE
00D346  05                +                 .BYTE   STRLEN("UNTIL")
00D347  554E54494C        +                 .BYTE   "UNTIL"
        0000D343          = LAST            .SET    THIS
                            UNTIL:          FORTH
00D34C  6ED0              +                 .WORD   DO_COLON-1
00D34E  74D210D2          :                 .WORD   DO_LITERAL,QUERY_BRANCH
00D352  8CC1              :                 .WORD   COMMA

Portable National Semiconductor SC/MP Assembler [16.09]

00D354  8CC1              :                 .WORD   COMMA
00D356  86CB              :                 .WORD   EXIT
                            
                            ; USER
                            
                                            WORD    "USER",NORMAL
        0000D358          = THIS            .SET    $
00D358  43D3              +                 .WORD   LAST
00D35A  00                +                 .BYTE   NORMAL
00D35B  04                +                 .BYTE   STRLEN("USER")
00D35C  55534552          +                 .BYTE   "USER"
        0000D358          = LAST            .SET    THIS
                            USER:           FORTH
00D360  6ED0              +                 .WORD   DO_COLON-1
00D362  38CB              :                 .WORD   CREATE
00D364  74D26ED3          :                 .WORD   DO_LITERAL,DO_USER
00D368  26CB              :                 .WORD   BUILD
00D36A  8CC1              :                 .WORD   COMMA
00D36C  86CB              :                 .WORD   EXIT
                            
                            DO_USER:
                                    .IF     0
                                            tdc
                                            dec     a                       ; Push on data stack
                                            dec     a
                                            tcd
                                            plx
                                            clc
                                            lda     !1,x
                                            adc     #USER_AREA
                                            sta     <1
                                            CONTINUE                        ; Done
                                    .ENDIF
00D36E  3F                :                 XPPC    R2
                            
                            ; VARIABLE ( “<spaces>name” -- )
                            ;
                            ; Skip leading space delimiters. Parse name delimited by a space. Create a
                            ; definition for name with the execution semantics defined below. Reserve one
                            ; cell of data space at an aligned address.
                            
                                            WORD    "VARIABLE",NORMAL
        0000D36F          = THIS            .SET    $
00D36F  58D3              +                 .WORD   LAST
00D371  00                +                 .BYTE   NORMAL
00D372  08                +                 .BYTE   STRLEN("VARIABLE")
00D373  5641524941424C45  +                 .BYTE   "VARIABLE"
        0000D36F          = LAST            .SET    THIS
                            VARIABLE:       FORTH
00D37B  6ED0              +                 .WORD   DO_COLON-1
00D37D  38CB              :                 .WORD   CREATE
00D37F  74D28FD3          :                 .WORD   DO_LITERAL,DO_VARIABLE
00D383  26CB              :                 .WORD   BUILD
00D385  74D20100          :                 .WORD   DO_LITERAL,1

Portable National Semiconductor SC/MP Assembler [16.09]

00D389  9DC2              :                 .WORD   CELLS
00D38B  EFC1              :                 .WORD   ALLOT
00D38D  86CB              :                 .WORD   EXIT
                            
                            DO_VARIABLE:
                                    .IF     0
                                            tdc
                                            dec     a
                                            dec     a
                                            tcd
                                            pla
                                            inc     a
                                            sta     <1
                                            CONTINUE
                                    .ENDIF
00D38F  3F                :                 XPPC    R2
                            
                            ; WHILE ( orig -- orig jump )
                            
                                            WORD    "WHILE",IMMEDIATE
        0000D390          = THIS            .SET    $
00D390  6FD3              +                 .WORD   LAST
00D392  80                +                 .BYTE   IMMEDIATE
00D393  05                +                 .BYTE   STRLEN("WHILE")
00D394  5748494C45        +                 .BYTE   "WHILE"
        0000D390          = LAST            .SET    THIS
                            WHILE:          FORTH
00D399  6ED0              +                 .WORD   DO_COLON-1
00D39B  74D210D2          :                 .WORD   DO_LITERAL,QUERY_BRANCH
00D39F  8CC1              :                 .WORD   COMMA
00D3A1  5FC2              :                 .WORD   HERE
00D3A3  DCC0              :                 .WORD   ZERO
00D3A5  8CC1              :                 .WORD   COMMA
00D3A7  86CB              :                 .WORD   EXIT
                            
                            ; WORDS ( -- )
                            ;
                            ;   LATEST @ BEGIN
                            ;       DUP COUNT TYPE SPACE
                            ;       NFA>LFA @
                            ;   DUP 0= UNTIL
                            ;   DROP ;
                            
                                            WORD    "WORDS",NORMAL
        0000D3A9          = THIS            .SET    $
00D3A9  90D3              +                 .WORD   LAST
00D3AB  00                +                 .BYTE   NORMAL
00D3AC  05                +                 .BYTE   STRLEN("WORDS")
00D3AD  574F524453        +                 .BYTE   "WORDS"
        0000D3A9          = LAST            .SET    THIS
                            WORDS:          FORTH
00D3B2  6ED0              +                 .WORD   DO_COLON-1
00D3B4  A8C0              :                 .WORD   LATEST
00D3B6  C9C1              :                 .WORD   FETCH

Portable National Semiconductor SC/MP Assembler [16.09]

00D3B8  5DC3              : WORDS_1:        .WORD   DUP
00D3BA  CCCF              :                 .WORD   COUNT
00D3BC  BCD4              :                 .WORD   TYPE
00D3BE  8AD4              :                 .WORD   SPACE
00D3C0  3DCE              :                 .WORD   NFA_TO_LFA
00D3C2  C9C1              :                 .WORD   FETCH
00D3C4  5DC3              :                 .WORD   DUP
00D3C6  A5C9              :                 .WORD   ZERO_EQUAL
00D3C8  10D2B8D3          :                 .WORD   QUERY_BRANCH,WORDS_1
00D3CC  4FC3              :                 .WORD   DROP
00D3CE  86CB              :                 .WORD   EXIT
                            
                            ; [
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   0 STATE !
                            
                                            WORD    "[",IMMEDIATE
        0000D3D0          = THIS            .SET    $
00D3D0  A9D3              +                 .WORD   LAST
00D3D2  80                +                 .BYTE   IMMEDIATE
00D3D3  01                +                 .BYTE   STRLEN("[")
00D3D4  5B                +                 .BYTE   "["
        0000D3D0          = LAST            .SET    THIS
                            LEFT_BRACKET:   FORTH
00D3D5  6ED0              +                 .WORD   DO_COLON-1
00D3D7  DCC0              :                 .WORD   ZERO
00D3D9  C8C0              :                 .WORD   STATE
00D3DB  32C1              :                 .WORD   STORE
00D3DD  86CB              :                 .WORD   EXIT
                            
                            ; [']
                            
                                            WORD    "[']",IMMEDIATE
        0000D3DF          = THIS            .SET    $
00D3DF  D0D3              +                 .WORD   LAST
00D3E1  80                +                 .BYTE   IMMEDIATE
00D3E2  03                +                 .BYTE   STRLEN("[']")
00D3E3  5B275D            +                 .BYTE   "[']"
        0000D3DF          = LAST            .SET    THIS
                            BRACKET_TICK:   FORTH
00D3E6  6ED0              +                 .WORD   DO_COLON-1
00D3E8  46D0              :                 .WORD   TICK
00D3EA  74D274D2          :                 .WORD   DO_LITERAL,DO_LITERAL
00D3EE  8CC1              :                 .WORD   COMMA
00D3F0  8CC1              :                 .WORD   COMMA
00D3F2  86CB              :                 .WORD   EXIT
                            
                            ; [CHAR]
                            ;
                            ;   CHAR ['] LIT ,XT  , ; IMMEDIATE
                            
                                            WORD    "[CHAR]",IMMEDIATE

Portable National Semiconductor SC/MP Assembler [16.09]

        0000D3F4          = THIS            .SET    $
00D3F4  DFD3              +                 .WORD   LAST
00D3F6  80                +                 .BYTE   IMMEDIATE
00D3F7  06                +                 .BYTE   STRLEN("[CHAR]")
00D3F8  5B434841525D      +                 .BYTE   "[CHAR]"
        0000D3F4          = LAST            .SET    THIS
                            BRACKET_CHAR:   FORTH
00D3FE  6ED0              +                 .WORD   DO_COLON-1
00D400  91D1              :                 .WORD   CHAR
00D402  74D274D2          :                 .WORD   DO_LITERAL,DO_LITERAL
00D406  8CC1              :                 .WORD   COMMA
00D408  8CC1              :                 .WORD   COMMA
00D40A  86CB              :                 .WORD   EXIT
                            
                            ; \ ( -- )
                            ;
                            ; Parse and discard the remainder of the parse area. \ is an immediate word.
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   1 WORD DROP
                            
                                            WORD    "\\",IMMEDIATE
        0000D40C          = THIS            .SET    $
00D40C  F4D3              +                 .WORD   LAST
00D40E  80                +                 .BYTE   IMMEDIATE
00D40F  01                +                 .BYTE   STRLEN("\\")
00D410  5C                +                 .BYTE   "\\"
        0000D40C          = LAST            .SET    THIS
                            BACKSLASH:      FORTH
00D411  6ED0              +                 .WORD   DO_COLON-1
00D413  74D20100          :                 .WORD   DO_LITERAL,1
00D417  02CF              :                 .WORD   WORD
00D419  4FC3              :                 .WORD   DROP
00D41B  86CB              :                 .WORD   EXIT
                            
                            ; ]
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   -1 STATE !
                            
                                            WORD    "]",NORMAL
        0000D41D          = THIS            .SET    $
00D41D  0CD4              +                 .WORD   LAST
00D41F  00                +                 .BYTE   NORMAL
00D420  01                +                 .BYTE   STRLEN("]")
00D421  5D                +                 .BYTE   "]"
        0000D41D          = LAST            .SET    THIS
                            RIGHT_BRACKET:  FORTH
00D422  6ED0              +                 .WORD   DO_COLON-1
00D424  74D2FFFF          :                 .WORD   DO_LITERAL,-1
00D428  C8C0              :                 .WORD   STATE
00D42A  32C1              :                 .WORD   STORE

Portable National Semiconductor SC/MP Assembler [16.09]

00D42C  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; I/O Operations
                            ;-------------------------------------------------------------------------------
                            
                            ; CR ( -- )
                            ;
                            ; Cause subsequent output to appear at the beginning of the next line.
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   13 EMIT 10 EMIT
                            
                                            WORD    "CR",NORMAL
        0000D42E          = THIS            .SET    $
00D42E  1DD4              +                 .WORD   LAST
00D430  00                +                 .BYTE   NORMAL
00D431  02                +                 .BYTE   STRLEN("CR")
00D432  4352              +                 .BYTE   "CR"
        0000D42E          = LAST            .SET    THIS
                            CR:             FORTH
00D434  6ED0              +                 .WORD   DO_COLON-1
00D436  74D20D00          :                 .WORD   DO_LITERAL,13
00D43A  4CD4              :                 .WORD   EMIT
00D43C  74D20A00          :                 .WORD   DO_LITERAL,10
00D440  4CD4              :                 .WORD   EMIT
00D442  86CB              :                 .WORD   EXIT
                            
                            ; EMIT ( x -- )
                            ;
                            ; If x is a graphic character in the implementation-defined character set,
                            ; display x. The effect of EMIT for all other values of x is implementation
                            ; -defined.
                            
                                            WORD    "EMIT",NORMAL
        0000D444          = THIS            .SET    $
00D444  2ED4              +                 .WORD   LAST
00D446  00                +                 .BYTE   NORMAL
00D447  04                +                 .BYTE   STRLEN("EMIT")
00D448  454D4954          +                 .BYTE   "EMIT"
        0000D444          = LAST            .SET    THIS
                            EMIT:           NATIVE
00D44C  4DD4              +                 .WORD   $+1
00D44E  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00D450  32                :                 XPAL    R1
00D451  C107              :                 LD      SP+1(MA)
00D453  36                :                 XPAH    R1
00D454  C200              :                 LD      0(R1)           ; Fetch and print the character
                                            TXD
00D456  20                +                 .byte   X'20
00D457  A906              :                 ILD     SP+0(MA)        ; Drop the top of stack
00D459  A906              :                 ILD     SP+0(MA)
00D45B  3F                :                 XPPC    R2              ; And continue

Portable National Semiconductor SC/MP Assembler [16.09]

                            
                            ; KEY ( -- char )
                            ;
                            ; Receive one character char, a member of the implementation-defined character
                            ; set. Keyboard events that do not correspond to such characters are discarded
                            ; until a valid character is received, and those events are subsequently
                            ; unavailable.
                            ;
                            ; All standard characters can be received. Characters received by KEY are not
                            ; displayed.
                            
                                            WORD    "KEY",NORMAL
        0000D45C          = THIS            .SET    $
00D45C  44D4              +                 .WORD   LAST
00D45E  00                +                 .BYTE   NORMAL
00D45F  03                +                 .BYTE   STRLEN("KEY")
00D460  4B4559            +                 .BYTE   "KEY"
        0000D45C          = LAST            .SET    THIS
                            KEY:            NATIVE
00D463  64D4              +                 .WORD   $+1
00D465  B906              :                 DLD     SP+0(MA)        ; Load the data stack pointer and
00D467  B906              :                 DLD     SP+0(MA)        ; .. create a new cell
00D469  32                :                 XPAL    R1
00D46A  C107              :                 LD      SP+1(MA)
00D46C  36                :                 XPAH    R1
                                            RXD                     ; Read a character from the keyboard
00D46D  21                +                 .byte   X'21
00D46E  CA00              :                 ST      0(R1)           ; .. then save on the stack
00D470  C400              :                 LDI     0
00D472  CA01              :                 ST      1(R1)
00D474  3F                :                 XPPC    R2              ; And continue
                            
                            
                            ; KEY? ( -- flag )
                            ;
                            ; If a character is available, return true. Otherwise, return false. If
                            ; non-character keyboard events are available before the first valid character,
                            ; they are discarded and are subsequently unavailable. The character shall be
                            ; returned by the next execution of KEY.
                            
                                            WORD    "KEY?",NORMAL
        0000D475          = THIS            .SET    $
00D475  5CD4              +                 .WORD   LAST
00D477  00                +                 .BYTE   NORMAL
00D478  04                +                 .BYTE   STRLEN("KEY?")
00D479  4B45593F          +                 .BYTE   "KEY?"
        0000D475          = LAST            .SET    THIS
00D47D  B6D1              : KEY_QUERY:      .WORD   DO_CONSTANT-1
00D47F  FFFF              :                 .WORD   -1
                            
                            ; SPACE ( -- )
                            ;
                            ; Display one space.
                            ;

Portable National Semiconductor SC/MP Assembler [16.09]

                            ; In this implementation it is defined as
                            ;
                            ;   BL EMIT
                            
                                            WORD    "SPACE",NORMAL
        0000D481          = THIS            .SET    $
00D481  75D4              +                 .WORD   LAST
00D483  00                +                 .BYTE   NORMAL
00D484  05                +                 .BYTE   STRLEN("SPACE")
00D485  5350414345        +                 .BYTE   "SPACE"
        0000D481          = LAST            .SET    THIS
                            SPACE:          FORTH
00D48A  6ED0              +                 .WORD   DO_COLON-1
00D48C  E6C0              :                 .WORD   BL
00D48E  4CD4              :                 .WORD   EMIT
00D490  86CB              :                 .WORD   EXIT
                            
                            ; SPACES ( n -- )
                            ;
                            ; If n is greater than zero, display n spaces.
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
                            
                                            WORD    "SPACES",NORMAL
        0000D492          = THIS            .SET    $
00D492  81D4              +                 .WORD   LAST
00D494  00                +                 .BYTE   NORMAL
00D495  06                +                 .BYTE   STRLEN("SPACES")
00D496  535041434553      +                 .BYTE   "SPACES"
        0000D492          = LAST            .SET    THIS
                            SPACES:         FORTH
00D49C  6ED0              +                 .WORD   DO_COLON-1
00D49E  5DC3              : SPACES_1:       .WORD   DUP
00D4A0  C2C9              :                 .WORD   ZERO_GREATER
00D4A2  10D2AED4          :                 .WORD   QUERY_BRANCH,SPACES_2
00D4A6  8AD4              :                 .WORD   SPACE
00D4A8  C0C5              :                 .WORD   ONE_MINUS
00D4AA  EFD19ED4          :                 .WORD   BRANCH,SPACES_1
00D4AE  4FC3              : SPACES_2:       .WORD   DROP
00D4B0  86CB              :                 .WORD   EXIT
                            
                            ; TYPE ( c-addr u -- )
                            ;
                            ; If u is greater than zero, display the character string specified by c-addr
                            ; and u.
                            ;
                            ; In this implementation it is defined as
                            ;
                            ;   ?DUP IF
                            ;     OVER + SWAP DO I C@ EMIT LOOP
                            ;   ELSE DROP THEN
                            

Portable National Semiconductor SC/MP Assembler [16.09]

                                            WORD    "TYPE",NORMAL
        0000D4B2          = THIS            .SET    $
00D4B2  92D4              +                 .WORD   LAST
00D4B4  00                +                 .BYTE   NORMAL
00D4B5  06                +                 .BYTE   STRLEN("NORMAL")
00D4B6  4E4F524D414C      +                 .BYTE   "NORMAL"
        0000D4B2          = LAST            .SET    THIS
                            TYPE:           FORTH
00D4BC  6ED0              +                 .WORD   DO_COLON-1
00D4BE  1FC3              :                 .WORD   QUERY_DUP
00D4C0  10D2DAD4          :                 .WORD   QUERY_BRANCH,TYPE_2
00D4C4  87C3              :                 .WORD   OVER
00D4C6  48C5              :                 .WORD   PLUS
00D4C8  E4C3              :                 .WORD   SWAP
00D4CA  CED1              :                 .WORD   DO_DO
00D4CC  7AC4              : TYPE_1:         .WORD   I
00D4CE  3AC2              :                 .WORD   C_FETCH
00D4D0  4CD4              :                 .WORD   EMIT
00D4D2  97D2CCD4          :                 .WORD   DO_LOOP,TYPE_1
00D4D6  EFD1DCD4          :                 .WORD   BRANCH,TYPE_3
00D4DA  4FC3              : TYPE_2          .WORD   DROP
00D4DC  86CB              : TYPE_3          .WORD   EXIT
                            
                            
                            ;===============================================================================
                            ; Formatted Output
                            ;-------------------------------------------------------------------------------
                            
                            ; # ( ud1 -- ud2 )
                            ;
                            ; Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n.
                            ; (n is the least-significant digit of ud1.) Convert n to external form and add
                            ; the resulting character to the beginning of the pictured numeric output string.
                            ; An ambiguous condition exists if # executes outside of a <# #> delimited
                            ; number conversion.
                            ;
                            ;       BASE @ >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ROT DUP 9 > 7 AND + 30 + HOLD
                            
                                            WORD    "#",NORMAL
        0000D4DE          = THIS            .SET    $
00D4DE  B2D4              +                 .WORD   LAST
00D4E0  00                +                 .BYTE   NORMAL
00D4E1  01                +                 .BYTE   STRLEN("#")
00D4E2  23                +                 .BYTE   "#"
        0000D4DE          = LAST            .SET    THIS
                            HASH:           FORTH
00D4E3  6ED0              +                 .WORD   DO_COLON-1
00D4E5  7DC0              :                 .WORD   BASE
00D4E7  C9C1              :                 .WORD   FETCH
00D4E9  52C4              :                 .WORD   TO_R
00D4EB  DCC0              :                 .WORD   ZERO
00D4ED  ECC4              :                 .WORD   R_FETCH
00D4EF  62C9              :                 .WORD   UM_SLASH_MOD
00D4F1  B7C3              :                 .WORD   ROT

Portable National Semiconductor SC/MP Assembler [16.09]

00D4F3  B7C3              :                 .WORD   ROT
00D4F5  C3C4              :                 .WORD   R_FROM
00D4F7  62C9              :                 .WORD   UM_SLASH_MOD
00D4F9  B7C3              :                 .WORD   ROT
00D4FB  B7C3              :                 .WORD   ROT
00D4FD  5DC3              :                 .WORD   DUP
00D4FF  74D20900          :                 .WORD   DO_LITERAL,9
00D503  01CA              :                 .WORD   GREATER
00D505  74D20700          :                 .WORD   DO_LITERAL,7
00D509  2CCA              :                 .WORD   AND
00D50B  48C5              :                 .WORD   PLUS
00D50D  74D23000          :                 .WORD   DO_LITERAL,'0'
00D511  48C5              :                 .WORD   PLUS
00D513  78D5              :                 .WORD   HOLD
00D515  86CB              :                 .WORD   EXIT
                            
                            ; #> ( xd -- c-addr u )
                            ;
                            ; Drop xd. Make the pictured numeric output string available as a character
                            ; string. c-addr and u specify the resulting character string. A program may
                            ; replace characters within the string.
                            ;
                            ;       2DROP HP @ PAD OVER -
                            
                                            WORD    "#>",NORMAL
        0000D517          = THIS            .SET    $
00D517  DED4              +                 .WORD   LAST
00D519  00                +                 .BYTE   NORMAL
00D51A  02                +                 .BYTE   STRLEN("#>")
00D51B  233E              +                 .BYTE   "#>"
        0000D517          = LAST            .SET    THIS
                            HASH_GREATER:   FORTH
00D51D  6ED0              +                 .WORD   DO_COLON-1
00D51F  D6C2              :                 .WORD   TWO_DROP
00D521  9AC0              :                 .WORD   HP
00D523  C9C1              :                 .WORD   FETCH
00D525  91D5              :                 .WORD   PAD
00D527  87C3              :                 .WORD   OVER
00D529  67C5              :                 .WORD   MINUS
00D52B  86CB              :                 .WORD   EXIT
                            
                            ; #S ( ud1 -- ud2 )
                            ;
                            ; Convert one digit of ud1 according to the rule for #. Continue conversion
                            ; until the quotient is zero. ud2 is zero. An ambiguous condition exists if #S
                            ; executes outside of a <# #> delimited number conversion.
                            ;
                            ;       BEGIN # 2DUP OR 0= UNTIL
                            
                                            WORD    "#S",NORMAL
        0000D52D          = THIS            .SET    $
00D52D  17D5              +                 .WORD   LAST
00D52F  00                +                 .BYTE   NORMAL
00D530  02                +                 .BYTE   STRLEN("#S")

Portable National Semiconductor SC/MP Assembler [16.09]

00D531  2353              +                 .BYTE   "#S"
        0000D52D          = LAST            .SET    THIS
                            HASH_S:         FORTH
00D533  6ED0              +                 .WORD   DO_COLON-1
00D535  E3D4              : HASH_S_1:       .WORD   HASH
00D537  E9C2              :                 .WORD   TWO_DUP
00D539  91CA              :                 .WORD   OR
00D53B  A5C9              :                 .WORD   ZERO_EQUAL
00D53D  10D235D5          :                 .WORD   QUERY_BRANCH,HASH_S_1
00D541  86CB              :                 .WORD   EXIT
                            
                            ; . ( n -- )
                            ;
                            ; Display n in free field format.
                            ;
                            ;       <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE
                            
                                            WORD    ".",NORMAL
        0000D543          = THIS            .SET    $
00D543  2DD5              +                 .WORD   LAST
00D545  00                +                 .BYTE   NORMAL
00D546  01                +                 .BYTE   STRLEN(".")
00D547  2E                +                 .BYTE   "."
        0000D543          = LAST            .SET    THIS
                            DOT:            FORTH
00D548  6ED0              +                 .WORD   DO_COLON-1
00D54A  66D5              :                 .WORD   LESS_HASH
00D54C  5DC3              :                 .WORD   DUP
00D54E  17C6              :                 .WORD   ABS
00D550  DCC0              :                 .WORD   ZERO
00D552  33D5              :                 .WORD   HASH_S
00D554  B7C3              :                 .WORD   ROT
00D556  9DD5              :                 .WORD   SIGN
00D558  1DD5              :                 .WORD   HASH_GREATER
00D55A  BCD4              :                 .WORD   TYPE
00D55C  8AD4              :                 .WORD   SPACE
00D55E  86CB              :                 .WORD   EXIT
                            
                            ; <# ( -- )
                            ;
                            ; Initialize the pictured numeric output conversion process.
                            ;
                            ;       PAD HP !
                            
                                            WORD    "<#",NORMAL
        0000D560          = THIS            .SET    $
00D560  43D5              +                 .WORD   LAST
00D562  00                +                 .BYTE   NORMAL
00D563  02                +                 .BYTE   STRLEN("<#")
00D564  3C23              +                 .BYTE   "<#"
        0000D560          = LAST            .SET    THIS
                            LESS_HASH:      FORTH
00D566  6ED0              +                 .WORD   DO_COLON-1
00D568  91D5              :                 .WORD   PAD

Portable National Semiconductor SC/MP Assembler [16.09]

00D56A  9AC0              :                 .WORD   HP
00D56C  32C1              :                 .WORD   STORE
00D56E  86CB              :                 .WORD   EXIT
                            
                            ; HOLD ( char -- )
                            
                            ; Add char to the beginning of the pictured numeric output string. An
                            ; ambiguous condition exists if HOLD executes outside of a <# #> delimited
                            ; number conversion.
                            ;
                            ;       -1 HP +!  HP @ C!
                            
                                            WORD    "HOLD",NORMAL
        0000D570          = THIS            .SET    $
00D570  60D5              +                 .WORD   LAST
00D572  00                +                 .BYTE   NORMAL
00D573  04                +                 .BYTE   STRLEN("HOLD")
00D574  484F4C44          +                 .BYTE   "HOLD"
        0000D570          = LAST            .SET    THIS
                            HOLD:           FORTH
00D578  6ED0              +                 .WORD   DO_COLON-1
00D57A  74D2FFFF          :                 .WORD   DO_LITERAL,-1
00D57E  9AC0              :                 .WORD   HP
00D580  5DC1              :                 .WORD   PLUS_STORE
00D582  9AC0              :                 .WORD   HP
00D584  C9C1              :                 .WORD   FETCH
00D586  FDC1              :                 .WORD   C_STORE
00D588  86CB              :                 .WORD   EXIT
                            
                            ; PAD ( -- c-addr )
                            ;
                            ; c-addr is the address of a transient region that can be used to hold data
                            ; for intermediate processing.
                            
                                            WORD    "PAD",NORMAL
        0000D58A          = THIS            .SET    $
00D58A  70D5              +                 .WORD   LAST
00D58C  00                +                 .BYTE   NORMAL
00D58D  03                +                 .BYTE   STRLEN("PAD")
00D58E  504144            +                 .BYTE   "PAD"
        0000D58A          = LAST            .SET    THIS
00D591  B6D1              : PAD:            .WORD   DO_CONSTANT-1
00D593  A811              :                 .WORD   PAD_END
                            
                            ; SIGN ( n -- )
                            ;
                            ; If n is negative, add a minus sign to the beginning of the pictured numeric
                            ; output string. An ambiguous condition exists if SIGN executes outside of a
                            ; <# #> delimited number conversion.
                            ;
                            ;       [ HEX ] 0< IF 2D HOLD THEN
                            
                                            WORD    "SIGN",NORMAL
        0000D595          = THIS            .SET    $

Portable National Semiconductor SC/MP Assembler [16.09]

00D595  8AD5              +                 .WORD   LAST
00D597  00                +                 .BYTE   NORMAL
00D598  04                +                 .BYTE   STRLEN("SIGN")
00D599  5349474E          +                 .BYTE   "SIGN"
        0000D595          = LAST            .SET    THIS
                            SIGN:           FORTH
00D59D  6ED0              +                 .WORD   DO_COLON-1
00D59F  6BC9              :                 .WORD   ZERO_LESS
00D5A1  10D2ABD5          :                 .WORD   QUERY_BRANCH,SIGN_1
00D5A5  74D22D00          :                 .WORD   DO_LITERAL,'-'
00D5A9  78D5              :                 .WORD   HOLD
00D5AB  86CB              : SIGN_1:         .WORD   EXIT
                            
                            ; U. ( u -- )
                            ;
                            ; Display u in free field format.
                            ;
                            ;  <# 0 #S #> TYPE SPACE
                            
                                            WORD    "U.",NORMAL
        0000D5AD          = THIS            .SET    $
00D5AD  95D5              +                 .WORD   LAST
00D5AF  00                +                 .BYTE   NORMAL
00D5B0  02                +                 .BYTE   STRLEN("U.")
00D5B1  552E              +                 .BYTE   "U."
        0000D5AD          = LAST            .SET    THIS
                            U_DOT:          FORTH
00D5B3  6ED0              +                 .WORD   DO_COLON-1
00D5B5  66D5              :                 .WORD   LESS_HASH
00D5B7  DCC0              :                 .WORD   ZERO
00D5B9  33D5              :                 .WORD   HASH_S
00D5BB  1DD5              :                 .WORD   HASH_GREATER
00D5BD  BCD4              :                 .WORD   TYPE
00D5BF  8AD4              :                 .WORD   SPACE
00D5C1  86CB              :                 .WORD   EXIT
                            
                            ;===============================================================================
                            ; Programming Tools
                            ;-------------------------------------------------------------------------------
                            
                            ; .NYBBLE ( n -- )
                            ;
                            ; Print the least significant nybble of the top value on the stack in hex.
                            
                            ;               WORD    ".NYBBLE",NORMAL
                            DOT_NYBBLE:     NATIVE
00D5C3  C4D5              +                 .WORD   $+1
00D5C5  C106              :                 LD      SP+0(MA)        ; Load the data stack pointer
00D5C7  32                :                 XPAL    R1
00D5C8  C107              :                 LD      SP+1(MA)
00D5CA  36                :                 XPAH    R1
00D5CB  C200              :                 LD      0(R1)           ; Fetch the nybble
00D5CD  D40F              :                 ANI     X'0F
00D5CF  01                :                 XAE

Portable National Semiconductor SC/MP Assembler [16.09]

00D5D0  C4DE              :                 LDI     LO(DIGITS)
00D5D2  32                :                 XPAL    R1
00D5D3  C4D5              :                 LDI     HI(DIGITS)
00D5D5  36                :                 XPAH    R1
00D5D6  C280              :                 LD      -128(R1)        ; Fetch a digit
                                            TXD
00D5D8  20                +                 .byte   X'20
00D5D9  A906              :                 ILD     SP+0(MA)        ; Drop the top cell
00D5DB  A906              :                 ILD     SP+0(MA)
00D5DD  3F                :                 XPPC    R2              ; And continue
                            
00D5DE  3031323334353637  : DIGITS:         .BYTE   "01234567"
00D5E6  3839414243444546  :                 .BYTE   "89ABCDEF"
                            
                            ; .BYTE ( n -- )
                            ;
                            ; Print least significant byte of top value on the stack in hex followed by
                            ; a space.
                            
                                            WORD    ".BYTE",NORMAL
        0000D5EE          = THIS            .SET    $
00D5EE  ADD5              +                 .WORD   LAST
00D5F0  00                +                 .BYTE   NORMAL
00D5F1  05                +                 .BYTE   STRLEN(".BYTE")
00D5F2  2E42595445        +                 .BYTE   ".BYTE"
        0000D5EE          = LAST            .SET    THIS
                            DOT_BYTE:       FORTH
00D5F7  6ED0              +                 .WORD   DO_COLON-1
00D5F9  5DC3              :                 .WORD   DUP
00D5FB  74D20400          :                 .WORD   DO_LITERAL,4
00D5FF  B4CA              :                 .WORD   RSHIFT
00D601  C3D5              :                 .WORD   DOT_NYBBLE
00D603  C3D5              :                 .WORD   DOT_NYBBLE
00D605  8AD4              :                 .WORD   SPACE
00D607  86CB              :                 .WORD   EXIT
                            
                            ; .WORD ( n -- )
                            ;
                            ; Print the top value on the stack in hex followed by a space.
                            
                                            WORD    ".WORD",NORMAL
        0000D609          = THIS            .SET    $
00D609  EED5              +                 .WORD   LAST
00D60B  00                +                 .BYTE   NORMAL
00D60C  05                +                 .BYTE   STRLEN(".WORD")
00D60D  2E574F5244        +                 .BYTE   ".WORD"
        0000D609          = LAST            .SET    THIS
                            DOT_WORD:       FORTH
00D612  6ED0              +                 .WORD   DO_COLON-1
00D614  5DC3              :                 .WORD   DUP
00D616  74D20C00          :                 .WORD   DO_LITERAL,12
00D61A  B4CA              :                 .WORD   RSHIFT
00D61C  C3D5              :                 .WORD   DOT_NYBBLE
00D61E  5DC3              :                 .WORD   DUP

Portable National Semiconductor SC/MP Assembler [16.09]

00D620  74D20800          :                 .WORD   DO_LITERAL,8
00D624  B4CA              :                 .WORD   RSHIFT
00D626  C3D5              :                 .WORD   DOT_NYBBLE
00D628  5DC3              :                 .WORD   DUP
00D62A  74D20400          :                 .WORD   DO_LITERAL,4
00D62E  B4CA              :                 .WORD   RSHIFT
00D630  C3D5              :                 .WORD   DOT_NYBBLE
00D632  C3D5              :                 .WORD   DOT_NYBBLE
00D634  8AD4              :                 .WORD   SPACE
00D636  86CB              :                 .WORD   EXIT
                            
                            ; .DP ( -- )
                            
                                            WORD    ".DP",NORMAL
        0000D638          = THIS            .SET    $
00D638  09D6              +                 .WORD   LAST
00D63A  00                +                 .BYTE   NORMAL
00D63B  03                +                 .BYTE   STRLEN(".DP")
00D63C  2E4450            +                 .BYTE   ".DP"
        0000D638          = LAST            .SET    THIS
                            DOT_DP:         FORTH
00D63F  6ED0              +                 .WORD   DO_COLON-1
00D641  A0D6              :                 .WORD   AT_DP
00D643  12D6              :                 .WORD   DOT_WORD
00D645  86CB              :                 .WORD   EXIT
                            
                            ; .RP ( -- )
                            
                                            WORD    ".RP",NORMAL
        0000D647          = THIS            .SET    $
00D647  38D6              +                 .WORD   LAST
00D649  00                +                 .BYTE   NORMAL
00D64A  03                +                 .BYTE   STRLEN(".RP")
00D64B  2E5250            +                 .BYTE   ".RP"
        0000D647          = LAST            .SET    THIS
                            DOT_RP:         FORTH
00D64E  6ED0              +                 .WORD   DO_COLON-1
00D650  BAD6              :                 .WORD   AT_RP
00D652  12D6              :                 .WORD   DOT_WORD
00D654  86CB              :                 .WORD   EXIT
                            
                            ; .S ( -- )
                            ;
                            ; Copy and display the values currently on the data stack. The format of the
                            ; display is implementation-dependent.
                            
                                            WORD    ".S",NORMAL
        0000D656          = THIS            .SET    $
00D656  47D6              +                 .WORD   LAST
00D658  00                +                 .BYTE   NORMAL
00D659  02                +                 .BYTE   STRLEN(".S")
00D65A  2E53              +                 .BYTE   ".S"
        0000D656          = LAST            .SET    THIS
                            DOT_S:          FORTH

Portable National Semiconductor SC/MP Assembler [16.09]

00D65C  6ED0              +                 .WORD   DO_COLON-1
00D65E  74D27B00          :                 .WORD   DO_LITERAL,'{'
00D662  4CD4              :                 .WORD   EMIT
00D664  8AD4              :                 .WORD   SPACE
00D666  A0D6              :                 .WORD   AT_DP
00D668  B0C5              :                 .WORD   ONE_PLUS
00D66A  74D28010          :                 .WORD   DO_LITERAL,DSTACK_END
00D66E  E4C3              :                 .WORD   SWAP
00D670  EED082D6          :                 .WORD   QUERY_DO_DO,DOT_S_2
00D674  7AC4              : DOT_S_1:        .WORD   I
00D676  C9C1              :                 .WORD   FETCH
00D678  12D6              :                 .WORD   DOT_WORD
00D67A  74D20200          :                 .WORD   DO_LITERAL,2
00D67E  3ED0              :                 .WORD   DO_PLUS_LOOP
00D680  74D6              :                 .WORD   DOT_S_1
00D682  74D27D00          : DOT_S_2:        .WORD   DO_LITERAL,'}'
00D686  4CD4              :                 .WORD   EMIT
00D688  8AD4              :                 .WORD   SPACE
00D68A  86CB              :                 .WORD   EXIT
                            
                            ; ? ( a-addr -- )
                            ;
                            ; Display the value stored at a-addr.
                            
                                            WORD    "?",NORMAL
        0000D68C          = THIS            .SET    $
00D68C  56D6              +                 .WORD   LAST
00D68E  00                +                 .BYTE   NORMAL
00D68F  01                +                 .BYTE   STRLEN("?")
00D690  3F                +                 .BYTE   "?"
        0000D68C          = LAST            .SET    THIS
                            QUERY:          FORTH
00D691  6ED0              +                 .WORD   DO_COLON-1
00D693  C9C1              :                 .WORD   FETCH
00D695  12D6              :                 .WORD   DOT_WORD
00D697  86CB              :                 .WORD   EXIT
                            
                            ; @DP ( -- a-addr )
                            
                                            WORD    "@DP",NORMAL
        0000D699          = THIS            .SET    $
00D699  8CD6              +                 .WORD   LAST
00D69B  00                +                 .BYTE   NORMAL
00D69C  03                +                 .BYTE   STRLEN("@DP")
00D69D  404450            +                 .BYTE   "@DP"
        0000D699          = LAST            .SET    THIS
                            AT_DP:
00D6A0  C106              :                 LD      SP+0(MA)        ; Save the original index
00D6A2  01                :                 XAE
00D6A3  B906              :                 DLD     SP+0(MA)        ; Reserve a new stack cell
00D6A5  B906              :                 DLD     SP+0(MA)        ; .. and load the data stack pointer
00D6A7  32                :                 XPAL    R1
00D6A8  C107              :                 LD      SP+1(MA)
00D6AA  36                :                 XPAH    R1

Portable National Semiconductor SC/MP Assembler [16.09]

00D6AB  40                :                 LDE                     ; Save the original value
00D6AC  CA00              :                 ST      0(R1)
00D6AE  C107              :                 LD      SP+1(MA)
00D6B0  CA01              :                 ST      1(R1)
00D6B2  3F                :                 XPPC    R2              ; And continue
                            
                            ; @DP ( -- a-addr )
                            
                                            WORD    "@RP",NORMAL
        0000D6B3          = THIS            .SET    $
00D6B3  99D6              +                 .WORD   LAST
00D6B5  00                +                 .BYTE   NORMAL
00D6B6  03                +                 .BYTE   STRLEN("@RP")
00D6B7  405250            +                 .BYTE   "@RP"
        0000D6B3          = LAST            .SET    THIS
                            AT_RP:
00D6BA  B906              :                 DLD     SP+0(MA)        ; Reserve a new stack cell
00D6BC  B906              :                 DLD     SP+0(MA)        ; .. and load the data stack pointer
00D6BE  32                :                 XPAL    R1
00D6BF  C107              :                 LD      SP+1(MA)
00D6C1  36                :                 XPAH    R1
00D6C2  C104              :                 LD      RP+0(MA)        ; Copy across the return stack pointer
00D6C4  CA00              :                 ST      0(R1)
00D6C6  C105              :                 LD      RP+1(MA)
00D6C8  CA01              :                 ST      1(R1)
00D6CA  3F                :                 XPPC    R2              ; And continue
                            
                            ;===============================================================================
                            ; Device Customisation
                            ;-------------------------------------------------------------------------------
                            
                            ; (TITLE) - ( -- )
                            ;
                            
                            ;               WORD    "(TITLE)",NORMAL
                            DO_TITLE:       FORTH
00D6CB  6ED0              +                 .WORD   DO_COLON-1
00D6CD  21D3              :                 .WORD   DO_S_QUOTE
00D6CF  1753432F4D502041> :                 .BYTE   23,"SC/MP ANS-Forth [16.09]"
00D6E7  86CB              :                 .WORD   EXIT
                            
                            ; BYE ( -- )
                            ;
                            ; Return control to the host operating system, if any.
                            
                                            WORD    "BYE",NORMAL
        0000D6E9          = THIS            .SET    $
00D6E9  B3D6              +                 .WORD   LAST
00D6EB  00                +                 .BYTE   NORMAL
00D6EC  03                +                 .BYTE   STRLEN("BYE")
00D6ED  425945            +                 .BYTE   "BYE"
        0000D6E9          = LAST            .SET    THIS
                            BYE:            NATIVE
00D6F0  F1D6              +                 .WORD   $+1

Portable National Semiconductor SC/MP Assembler [16.09]

00D6F2  C400              :                 LDI     0               ; Load address zero
00D6F4  33                :                 XPAL    R2
00D6F5  C400              :                 LDI     0
00D6F7  37                :                 XPAH    R2
00D6F8  3F                :                 XPPC    R2              ; And restart NIBL
                            
                            ; UNUSED ( -- u )
                            ;
                            ; u is the amount of space remaining in the region addressed by HERE , in
                            ; address units.
                            
                                            WORD    "UNUSED",NORMAL
        0000D6F9          = THIS            .SET    $
00D6F9  E9D6              +                 .WORD   LAST
00D6FB  00                +                 .BYTE   NORMAL
00D6FC  06                +                 .BYTE   STRLEN("UNUSED")
00D6FD  554E55534544      +                 .BYTE   "UNUSED"
        0000D6F9          = LAST            .SET    THIS
                            UNUSED:         FORTH
00D703  6ED0              +                 .WORD   DO_COLON-1
00D705  74D20080          :                 .WORD   DO_LITERAL,X'8000
00D709  5FC2              :                 .WORD   HERE
00D70B  67C5              :                 .WORD   MINUS
00D70D  86CB              :                 .WORD   EXIT
                            
        0000D6F9          = LAST_WORD       .EQU    LAST
                            
                                            .END


Portable National Semiconductor SC/MP Assembler [16.09]

Symbol Table

ABORT                            0000CB15  | IP                               00000000 
ABORT_QUOTE                      0000D159  | NORMAL                           00000000 
ABS                              0000C617  | PC                               00000000 
ABS.SKIP                         0000C623  | TO_IN_OFFSET                     00000000 
ACCEPT                           0000CCA8  | MA                               00000001 
ACCEPT_1                         0000CCB2  | BASE_OFFSET                      00000002 
ACCEPT_2                         0000CCF4  | R1                               00000002 
ACCEPT_3                         0000CD02  | WA                               00000002 
ACCEPT_4                         0000CD06  | R2                               00000003 
AGAIN                            0000D16E  | BLK_OFFSET                       00000004 
ALIGN                            0000C270  | RP                               00000004 
ALIGNED                          0000C27E  | DP_OFFSET                        00000006 
ALLOT                            0000C1EF  | SP                               00000006 
AND                              0000CA2C  | LATEST_OFFSET                    00000008 
AT_DP                            0000D6A0  | UP                               00000008 
AT_RP                            0000D6BA  | SCR_OFFSET                       0000000A 
BACKSLASH                        0000D411  | SOURCEID_OFFSET                  0000000C 
BASE                             0000C07D  | STATE_OFFSET                     0000000E 
BASE_OFFSET                      00000002  | BUFFER_OFFSET                    00000010 
BEGIN                            0000D183  | LENGTH_OFFSET                    00000012 
BL                               0000C0E6  | HP_OFFSET                        00000014 
BLANK                            0000CF7C  | IMMEDIATE                        00000080 
BLANK_1                          0000CF8C  | TIB_SIZE                         00000080 
BLANK_2                          0000CF98  | DSTACK                           00001000 
BLK                              0000C088  | DSTACK_END                       00001080 
BLK_OFFSET                       00000004  | TIB_AREA                         00001080 
BRACKET_CHAR                     0000D3FE  | RSTACK                           00001100 
BRACKET_TICK                     0000D3E6  | PAD_AREA                         00001180 
BRANCH                           0000D1EF  | RSTACK_END                       00001180 
BUFFER                           0000C08C  | PAD_END                          000011A8 
BUFFER_OFFSET                    00000010  | SYS_VARS                         000011A8 
BUILD                            0000CB26  | USR_VARS                         000011B2 
BYE                              0000D6F0  | NEXT_WORD                        000011C8 
CELLS                            0000C29D  | COLD                             0000C02E 
CELL_PLUS                        0000C28A  | HASH_TIB                         0000C064 
CHAR                             0000D191  | TO_IN                            0000C071 
CHARS                            0000C2CA  | BASE                             0000C07D 
CHAR_MINUS                       0000C2BB  | BLK                              0000C088 
CHAR_PLUS                        0000C2AC  | BUFFER                           0000C08C 
CMOVE                            0000CFA5  | DP                               0000C096 
CMOVE_GREATER                    0000CFB2  | HP                               0000C09A 
COLD                             0000C02E  | LATEST                           0000C0A8 
COLON                            0000D061  | LENGTH                           0000C0AC 
COMMA                            0000C18C  | SCR                              0000C0B7 
COMPARE                          0000CFC0  | SOURCEID                         0000C0BB 
CONSTANT                         0000D1A9  | STATE                            0000C0C8 
COUNT                            0000CFCC  | TIB                              0000C0D3 
CR                               0000D434  | ZERO                             0000C0DC 
CREATE                           0000CB38  | BL                               0000C0E6 
C_COMMA                          0000C224  | FALSE                            0000C0F3 
C_FETCH                          0000C23A  | TRUE                             0000C0FF 
C_STORE                          0000C1FD  | DECIMAL                          0000C10E 

Portable National Semiconductor SC/MP Assembler [16.09]

DABS                             0000C82B  | HEX                              0000C121 
DABS.SKIP                        0000C837  | STORE                            0000C132 
DASH_TRAILING                    0000CF55  | PLUS_STORE                       0000C15D 
DECIMAL                          0000C10E  | COMMA                            0000C18C 
DEPTH                            0000C337  | TWO_STORE                        0000C1A2 
DIGITS                           0000D5DE  | TWO_FETCH                        0000C1B6 
DIGIT_QUERY                      0000CD1A  | FETCH                            0000C1C9 
DMAX                             0000C841  | ALLOT                            0000C1EF 
DMAX.SKIP                        0000C84F  | C_STORE                          0000C1FD 
DMIN                             0000C85B  | C_COMMA                          0000C224 
DMIN.SKIP                        0000C86B  | C_FETCH                          0000C23A 
DNEGATE                          0000C87A  | HERE                             0000C25F 
DO                               0000D1C0  | ALIGN                            0000C270 
DOT                              0000D548  | ALIGNED                          0000C27E 
DOT_BYTE                         0000D5F7  | CELL_PLUS                        0000C28A 
DOT_DP                           0000D63F  | CELLS                            0000C29D 
DOT_NYBBLE                       0000D5C3  | CHAR_PLUS                        0000C2AC 
DOT_PAREN                        0000CFFD  | CHAR_MINUS                       0000C2BB 
DOT_QUOTE                        0000D011  | CHARS                            0000C2CA 
DOT_RP                           0000D64E  | TWO_DROP                         0000C2D6 
DOT_S                            0000D65C  | TWO_DUP                          0000C2E9 
DOT_S_1                          0000D674  | TWO_OVER                         0000C2FA 
DOT_S_2                          0000D682  | TWO_ROT                          0000C306 
DOT_WORD                         0000D612  | TWO_SWAP                         0000C313 
DO_ABORT                         0000CB1B  | QUERY_DUP                        0000C31F 
DO_COLON                         0000D06F  | DEPTH                            0000C337 
DO_CONSTANT                      0000D1B7  | DROP                             0000C34F 
DO_DO                            0000D1CE  | DUP                              0000C35D 
DO_LITERAL                       0000D274  | NIP                              0000C377 
DO_LOOP                          0000D297  | OVER                             0000C387 
DO_LOOP_END                      0000D299  | PICK                             0000C3A2 
DO_PLOOP_END                     0000D040  | ROLL                             0000C3AD 
DO_PLUS_LOOP                     0000D03E  | ROT                              0000C3B7 
DO_QUIT                          0000CBD2  | SWAP                             0000C3E4 
DO_S_QUOTE                       0000D321  | TUCK                             0000C409 
DO_TITLE                         0000D6CB  | TWO_TO_R                         0000C418 
DO_TWO_CONSTANT                  0000D10E  | TWO_R_FROM                       0000C429 
DO_TWO_LITERAL                   0000D12B  | TWO_R_FETCH                      0000C43A 
DO_USER                          0000D36E  | TO_R                             0000C452 
DO_VARIABLE                      0000D38F  | I                                0000C47A 
DP                               0000C096  | J                                0000C49E 
DP_OFFSET                        00000006  | R_FROM                           0000C4C3 
DROP                             0000C34F  | R_FETCH                          0000C4EC 
DSTACK                           00001000  | STAR                             0000C510 
DSTACK_END                       00001080  | STAR_SLASH                       0000C51E 
DUP                              0000C35D  | STAR_SLASH_MOD                   0000C537 
D_EQUAL                          0000C81B  | PLUS                             0000C548 
D_LESS                           0000C80D  | MINUS                            0000C567 
D_MINUS                          0000C744  | SLASH                            0000C586 
D_PLUS                           0000C714  | SLASH_MOD                        0000C59E 
D_TO_S                           0000C8A3  | ONE_PLUS                         0000C5B0 
D_TWO_SLASH                      0000C7E7  | ONE_MINUS                        0000C5C0 
D_TWO_STAR                       0000C7BE  | TWO_STAR                         0000C5D0 
D_ZERO_EQUAL                     0000C798  | TWO_SLASH                        0000C5EC 

Portable National Semiconductor SC/MP Assembler [16.09]

D_ZERO_EQUAL.ZERO                0000C7AC  | QUERY_NEGATE                     0000C604 
D_ZERO_LESS                      0000C775  | QUERY_NEGATE.SKIP                0000C60E 
ELSE                             0000D1D9  | ABS                              0000C617 
EMIT                             0000D44C  | ABS.SKIP                         0000C623 
EQUAL                            0000C9F4  | FM_SLASH_MOD                     0000C62F 
EVALUATE                         0000CD58  | FM_SLASH_MOD.SKIP                0000C667 
EXECUTE                          0000CB61  | MAX                              0000C674 
EXIT                             0000CB86  | MAX.SKIP                         0000C680 
FALSE                            0000C0F3  | MIN                              0000C68B 
FETCH                            0000C1C9  | MIN.SKIP                         0000C697 
FIND                             0000CDEF  | MOD                              0000C6A2 
FIND1                            0000CDF5  | NEGATE                           0000C6BA 
FIND2                            0000CE0D  | UMAX                             0000C6D8 
FIND3                            0000CE2B  | UMAX.SKIP                        0000C6E4 
FM_SLASH_MOD                     0000C62F  | UMIN                             0000C6F0 
FM_SLASH_MOD.SKIP                0000C667  | UMIN.SKIP                        0000C6FE 
GREATER                          0000CA01  | QUERY_DNEGATE                    0000C702 
HASH                             0000D4E3  | QUERY_DNEGATE.SKIP               0000C70C 
HASH_GREATER                     0000D51D  | D_PLUS                           0000C714 
HASH_S                           0000D533  | D_MINUS                          0000C744 
HASH_S_1                         0000D535  | D_ZERO_LESS                      0000C775 
HASH_TIB                         0000C064  | D_ZERO_EQUAL                     0000C798 
HERE                             0000C25F  | D_ZERO_EQUAL.ZERO                0000C7AC 
HEX                              0000C121  | D_TWO_STAR                       0000C7BE 
HOLD                             0000D578  | D_TWO_SLASH                      0000C7E7 
HP                               0000C09A  | D_LESS                           0000C80D 
HP_OFFSET                        00000014  | D_EQUAL                          0000C81B 
I                                0000C47A  | DABS                             0000C82B 
IF                               0000D200  | DABS.SKIP                        0000C837 
IMMED                            0000D24D  | DMAX                             0000C841 
IMMEDIATE                        00000080  | DMAX.SKIP                        0000C84F 
IMMED_QUERY                      0000CE2D  | DMIN                             0000C85B 
INTERPRET                        0000CD8D  | DMIN.SKIP                        0000C86B 
INTERPRET_1                      0000CD8F  | DNEGATE                          0000C87A 
INTERPRET_2                      0000CDB7  | D_TO_S                           0000C8A3 
INTERPRET_3                      0000CDB9  | M_STAR                           0000C8B0 
INTERPRET_4                      0000CDBD  | M_PLUS                           0000C8CE 
INTERPRET_5                      0000CDD1  | S_TO_D                           0000C8FB 
INTERPRET_6                      0000CDDF  | SM_SLASH_REM                     0000C90D 
INTERPRET_7                      0000CDE3  | UD_STAR                          0000C938 
INVERT                           0000CA4F  | UM_STAR                          0000C955 
IP                               00000000  | UM_SLASH_MOD                     0000C962 
J                                0000C49E  | ZERO_LESS                        0000C96B 
KEY                              0000D463  | ZERO_NOT_EQUAL                   0000C98A 
KEY_QUERY                        0000D47D  | ZERO_NOT_EQUAL.ZERO              0000C99A 
LAST                             0000D6F9  | ZERO_EQUAL                       0000C9A5 
LAST_WORD                        0000D6F9  | ZERO_EQUAL.ZERO                  0000C9B5 
LATEST                           0000C0A8  | ZERO_GREATER                     0000C9C2 
LATEST_OFFSET                    00000008  | LESS                             0000C9D7 
LEFT_BRACKET                     0000D3D5  | NOT_EQUAL                        0000C9E5 
LEFT_PAREN                       0000CFEB  | EQUAL                            0000C9F4 
LENGTH                           0000C0AC  | GREATER                          0000CA01 
LENGTH_OFFSET                    00000012  | U_LESS                           0000CA0F 
LESS                             0000C9D7  | U_GREATER                        0000CA1D 

Portable National Semiconductor SC/MP Assembler [16.09]

LESS_HASH                        0000D566  | AND                              0000CA2C 
LITERAL                          0000D268  | INVERT                           0000CA4F 
LOOP                             0000D27F  | LSHIFT                           0000CA61 
LOOP_1                           0000D295  | LSHIFT.LOOP                      0000CA69 
LSHIFT                           0000CA61  | LSHIFT.DECR                      0000CA82 
LSHIFT.DECR                      0000CA82  | LSHIFT.DONE                      0000CA86 
LSHIFT.DONE                      0000CA86  | OR                               0000CA91 
LSHIFT.LOOP                      0000CA69  | RSHIFT                           0000CAB4 
MA                               00000001  | RSHIFT.LOOP                      0000CABC 
MAX                              0000C674  | RSHIFT.DECR                      0000CAD3 
MAX.SKIP                         0000C680  | RSHIFT.DONE                      0000CAD7 
MIN                              0000C68B  | XOR                              0000CAE3 
MIN.SKIP                         0000C697  | QUERY_ABORT                      0000CAFC 
MINUS                            0000C567  | QUERY_ABORT.SKIP                 0000CB08 
MOD                              0000C6A2  | ABORT                            0000CB15 
M_PLUS                           0000C8CE  | DO_ABORT                         0000CB1B 
M_STAR                           0000C8B0  | BUILD                            0000CB26 
NEGATE                           0000C6BA  | CREATE                           0000CB38 
NEXT                             0000D08A  | EXECUTE                          0000CB61 
NEXT.SKIPH                       0000D09C  | EXIT                             0000CB86 
NEXT.SKIPL                       0000D096  | QUIT                             0000CBA3 
NEXT_WORD                        000011C8  | QUIT_1                           0000CBB3 
NFA_TO_CFA                       0000CE35  | QUIT_2                           0000CBBB 
NFA_TO_LFA                       0000CE3D  | QUIT_3                           0000CBCE 
NIP                              0000C377  | DO_QUIT                          0000CBD2 
NONAME                           0000D0B6  | QUERY_NUMBER                     0000CBE8 
NORMAL                           00000000  | QNUM_1                           0000CC0A 
NOT_EQUAL                        0000C9E5  | QNUM_2                           0000CC16 
ONE_MINUS                        0000C5C0  | QNUM_3                           0000CC1A 
ONE_PLUS                         0000C5B0  | QUERY_SIGN                       0000CC25 
OR                               0000CA91  | QUERY_SIGN.SKIP                  0000CC4F 
OVER                             0000C387  | TO_COUNTED                       0000CC51 
PAD                              0000D591  | TO_NUMBER                        0000CC6A 
PAD_AREA                         00001180  | TO_NUM_1                         0000CC6C 
PAD_END                          000011A8  | TO_NUM_2                         0000CC82 
PC                               00000000  | TO_NUM_3                         0000CC9C 
PICK                             0000C3A2  | ACCEPT                           0000CCA8 
PLUS                             0000C548  | ACCEPT_1                         0000CCB2 
PLUS_LOOP                        0000D026  | ACCEPT_2                         0000CCF4 
PLUS_LOOP_1                      0000D03C  | ACCEPT_3                         0000CD02 
PLUS_STORE                       0000C15D  | ACCEPT_4                         0000CD06 
POSTPONE                         0000D2A6  | DIGIT_QUERY                      0000CD1A 
POSTPONE_1                       0000D2CA  | EVALUATE                         0000CD58 
POSTPONE_2                       0000D2CC  | INTERPRET                        0000CD8D 
QNUM_1                           0000CC0A  | INTERPRET_1                      0000CD8F 
QNUM_2                           0000CC16  | INTERPRET_2                      0000CDB7 
QNUM_3                           0000CC1A  | INTERPRET_3                      0000CDB9 
QUERY                            0000D691  | INTERPRET_4                      0000CDBD 
QUERY_ABORT                      0000CAFC  | INTERPRET_5                      0000CDD1 
QUERY_ABORT.SKIP                 0000CB08  | INTERPRET_6                      0000CDDF 
QUERY_BRANCH                     0000D210  | INTERPRET_7                      0000CDE3 
QUERY_BRANCH.CONTINUE            0000D233  | FIND                             0000CDEF 
QUERY_BRANCH.SKIP1               0000D239  | FIND1                            0000CDF5 
QUERY_BRANCH.SKIP2               0000D23F  | FIND2                            0000CE0D 

Portable National Semiconductor SC/MP Assembler [16.09]

QUERY_DNEGATE                    0000C702  | FIND3                            0000CE2B 
QUERY_DNEGATE.SKIP               0000C70C  | IMMED_QUERY                      0000CE2D 
QUERY_DO                         0000D0DC  | NFA_TO_CFA                       0000CE35 
QUERY_DO_DO                      0000D0EE  | NFA_TO_LFA                       0000CE3D 
QUERY_DO_DO_1                    0000D0F0  | REFILL                           0000CE51 
QUERY_DUP                        0000C31F  | REFILL_1                         0000CE79 
QUERY_NEGATE                     0000C604  | RESTORE_INPUT                    0000CE8E 
QUERY_NEGATE.SKIP                0000C60E  | S_EQUAL                          0000CEA4 
QUERY_NUMBER                     0000CBE8  | SAVE_INPUT                       0000CEB5 
QUERY_SIGN                       0000CC25  | SCAN                             0000CEC9 
QUERY_SIGN.SKIP                  0000CC4F  | SKIP                             0000CECC 
QUIT                             0000CBA3  | SOURCE                           0000CED9 
QUIT_1                           0000CBB3  | SOURCE_ID                        0000CEF2 
QUIT_2                           0000CBBB  | WORD                             0000CF02 
QUIT_3                           0000CBCE  | WORD_1                           0000CF26 
R1                               00000002  | DASH_TRAILING                    0000CF55 
R2                               00000003  | SLASH_STRING                     0000CF63 
RECURSE                          0000D2D9  | BLANK                            0000CF7C 
REFILL                           0000CE51  | BLANK_1                          0000CF8C 
REFILL_1                         0000CE79  | BLANK_2                          0000CF98 
REPEAT                           0000D2EF  | CMOVE                            0000CFA5 
RESTORE_INPUT                    0000CE8E  | CMOVE_GREATER                    0000CFB2 
RIGHT_BRACKET                    0000D422  | COMPARE                          0000CFC0 
ROLL                             0000C3AD  | COUNT                            0000CFCC 
ROT                              0000C3B7  | SEARCH                           0000CFE2 
RP                               00000004  | LEFT_PAREN                       0000CFEB 
RSHIFT                           0000CAB4  | DOT_PAREN                        0000CFFD 
RSHIFT.DECR                      0000CAD3  | DOT_QUOTE                        0000D011 
RSHIFT.DONE                      0000CAD7  | PLUS_LOOP                        0000D026 
RSHIFT.LOOP                      0000CABC  | PLUS_LOOP_1                      0000D03C 
RSTACK                           00001100  | DO_PLUS_LOOP                     0000D03E 
RSTACK_END                       00001180  | DO_PLOOP_END                     0000D040 
R_FETCH                          0000C4EC  | TICK                             0000D046 
R_FROM                           0000C4C3  | TICK_1                           0000D05A 
SAVE_INPUT                       0000CEB5  | COLON                            0000D061 
SCAN                             0000CEC9  | DO_COLON                         0000D06F 
SCR                              0000C0B7  | NEXT                             0000D08A 
SCR_OFFSET                       0000000A  | NEXT.SKIPL                       0000D096 
SEARCH                           0000CFE2  | NEXT.SKIPH                       0000D09C 
SEMICOLON                        0000D0C9  | NONAME                           0000D0B6 
SIGN                             0000D59D  | SEMICOLON                        0000D0C9 
SIGN_1                           0000D5AB  | QUERY_DO                         0000D0DC 
SKIP                             0000CECC  | QUERY_DO_DO                      0000D0EE 
SLASH                            0000C586  | QUERY_DO_DO_1                    0000D0F0 
SLASH_MOD                        0000C59E  | TWO_CONSTANT                     0000D0FE 
SLASH_STRING                     0000CF63  | DO_TWO_CONSTANT                  0000D10E 
SM_SLASH_REM                     0000C90D  | TWO_LITERAL                      0000D11D 
SOURCE                           0000CED9  | DO_TWO_LITERAL                   0000D12B 
SOURCEID                         0000C0BB  | TWO_VARIABLE                     0000D13B 
SOURCEID_OFFSET                  0000000C  | ABORT_QUOTE                      0000D159 
SOURCE_ID                        0000CEF2  | AGAIN                            0000D16E 
SP                               00000006  | BEGIN                            0000D183 
SPACE                            0000D48A  | CHAR                             0000D191 
SPACES                           0000D49C  | CONSTANT                         0000D1A9 

Portable National Semiconductor SC/MP Assembler [16.09]

SPACES_1                         0000D49E  | DO_CONSTANT                      0000D1B7 
SPACES_2                         0000D4AE  | DO                               0000D1C0 
STAR                             0000C510  | DO_DO                            0000D1CE 
STAR_SLASH                       0000C51E  | ELSE                             0000D1D9 
STAR_SLASH_MOD                   0000C537  | BRANCH                           0000D1EF 
STATE                            0000C0C8  | IF                               0000D200 
STATE_OFFSET                     0000000E  | QUERY_BRANCH                     0000D210 
STORE                            0000C132  | QUERY_BRANCH.CONTINUE            0000D233 
SWAP                             0000C3E4  | QUERY_BRANCH.SKIP1               0000D239 
SYS_VARS                         000011A8  | QUERY_BRANCH.SKIP2               0000D23F 
S_EQUAL                          0000CEA4  | IMMED                            0000D24D 
S_QUOTE                          0000D309  | LITERAL                          0000D268 
S_TO_D                           0000C8FB  | DO_LITERAL                       0000D274 
THEN                             0000D339  | LOOP                             0000D27F 
THIS                             0000D6F9  | LOOP_1                           0000D295 
TIB                              0000C0D3  | DO_LOOP                          0000D297 
TIB_AREA                         00001080  | DO_LOOP_END                      0000D299 
TIB_SIZE                         00000080  | POSTPONE                         0000D2A6 
TICK                             0000D046  | POSTPONE_1                       0000D2CA 
TICK_1                           0000D05A  | POSTPONE_2                       0000D2CC 
TO_COUNTED                       0000CC51  | RECURSE                          0000D2D9 
TO_IN                            0000C071  | REPEAT                           0000D2EF 
TO_IN_OFFSET                     00000000  | S_QUOTE                          0000D309 
TO_NUMBER                        0000CC6A  | DO_S_QUOTE                       0000D321 
TO_NUM_1                         0000CC6C  | THEN                             0000D339 
TO_NUM_2                         0000CC82  | UNTIL                            0000D34C 
TO_NUM_3                         0000CC9C  | USER                             0000D360 
TO_R                             0000C452  | DO_USER                          0000D36E 
TRUE                             0000C0FF  | VARIABLE                         0000D37B 
TUCK                             0000C409  | DO_VARIABLE                      0000D38F 
TWO_CONSTANT                     0000D0FE  | WHILE                            0000D399 
TWO_DROP                         0000C2D6  | WORDS                            0000D3B2 
TWO_DUP                          0000C2E9  | WORDS_1                          0000D3B8 
TWO_FETCH                        0000C1B6  | LEFT_BRACKET                     0000D3D5 
TWO_LITERAL                      0000D11D  | BRACKET_TICK                     0000D3E6 
TWO_OVER                         0000C2FA  | BRACKET_CHAR                     0000D3FE 
TWO_ROT                          0000C306  | BACKSLASH                        0000D411 
TWO_R_FETCH                      0000C43A  | RIGHT_BRACKET                    0000D422 
TWO_R_FROM                       0000C429  | CR                               0000D434 
TWO_SLASH                        0000C5EC  | EMIT                             0000D44C 
TWO_STAR                         0000C5D0  | KEY                              0000D463 
TWO_STORE                        0000C1A2  | KEY_QUERY                        0000D47D 
TWO_SWAP                         0000C313  | SPACE                            0000D48A 
TWO_TO_R                         0000C418  | SPACES                           0000D49C 
TWO_VARIABLE                     0000D13B  | SPACES_1                         0000D49E 
TYPE                             0000D4BC  | SPACES_2                         0000D4AE 
TYPE_1                           0000D4CC  | TYPE                             0000D4BC 
TYPE_2                           0000D4DA  | TYPE_1                           0000D4CC 
TYPE_3                           0000D4DC  | TYPE_2                           0000D4DA 
UD_STAR                          0000C938  | TYPE_3                           0000D4DC 
UMAX                             0000C6D8  | HASH                             0000D4E3 
UMAX.SKIP                        0000C6E4  | HASH_GREATER                     0000D51D 
UMIN                             0000C6F0  | HASH_S                           0000D533 
UMIN.SKIP                        0000C6FE  | HASH_S_1                         0000D535 

Portable National Semiconductor SC/MP Assembler [16.09]

UM_SLASH_MOD                     0000C962  | DOT                              0000D548 
UM_STAR                          0000C955  | LESS_HASH                        0000D566 
UNTIL                            0000D34C  | HOLD                             0000D578 
UNUSED                           0000D703  | PAD                              0000D591 
UP                               00000008  | SIGN                             0000D59D 
USER                             0000D360  | SIGN_1                           0000D5AB 
USR_VARS                         000011B2  | U_DOT                            0000D5B3 
U_DOT                            0000D5B3  | DOT_NYBBLE                       0000D5C3 
U_GREATER                        0000CA1D  | DIGITS                           0000D5DE 
U_LESS                           0000CA0F  | DOT_BYTE                         0000D5F7 
VARIABLE                         0000D37B  | DOT_WORD                         0000D612 
WA                               00000002  | DOT_DP                           0000D63F 
WHILE                            0000D399  | DOT_RP                           0000D64E 
WORD                             0000CF02  | DOT_S                            0000D65C 
WORDS                            0000D3B2  | DOT_S_1                          0000D674 
WORDS_1                          0000D3B8  | DOT_S_2                          0000D682 
WORD_1                           0000CF26  | QUERY                            0000D691 
XOR                              0000CAE3  | AT_DP                            0000D6A0 
ZERO                             0000C0DC  | AT_RP                            0000D6BA 
ZERO_EQUAL                       0000C9A5  | DO_TITLE                         0000D6CB 
ZERO_EQUAL.ZERO                  0000C9B5  | BYE                              0000D6F0 
ZERO_GREATER                     0000C9C2  | LAST                             0000D6F9 
ZERO_LESS                        0000C96B  | LAST_WORD                        0000D6F9 
ZERO_NOT_EQUAL                   0000C98A  | THIS                             0000D6F9 
ZERO_NOT_EQUAL.ZERO              0000C99A  | UNUSED                           0000D703 
